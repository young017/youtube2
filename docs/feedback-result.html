<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>피드백 결과 - 1등 유튜버 되기</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    
    <style>
        :root {
            --primary-color: #ff0000;
            --secondary-color: #1a1a1a;
            --accent-color: #ff3333;
            --text-dark: #ffffff;
            --text-light: #cccccc;
            --bg-light: #0a0a0a;
            --bg-dark: #000000;
        }
        
        body {
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ffffff;
        }
        
        .hero-section {
            background-color: #000000;
            color: #ffffff;
            padding: 100px 0;
            border-bottom: 3px solid #ff0000;
        }
        
        .navbar {
            background-color: rgba(0, 0, 0, 0.95) !important;
            border-bottom: 2px solid #ff0000;
            backdrop-filter: blur(10px);
        }
        
        .navbar-brand {
            font-weight: bold;
            font-size: 1.5rem;
            color: #ff0000 !important;
        }
        
        .nav-link {
            color: #ffffff !important;
            font-weight: 500;
        }
        
        .nav-link:hover {
            color: #ff0000 !important;
        }
        
        .navbar-toggler {
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba(255, 0, 0, 1)' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }
        
        .btn-outline-light {
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            background: transparent;
            padding: 15px 35px;
            border-radius: 50px;
            font-weight: 600;
            font-size: 1.3rem;
            transition: all 0.3s ease;
        }
        
        .btn-outline-light:hover {
            background: var(--primary-color);
            color: white;
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 0, 0, 0.5);
        }
        
        .feedback-card {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 20px 60px rgba(255, 0, 0, 0.2);
            color: #ffffff;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .feedback-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #ff0000 0%, #cc0000 100%);
        }
        
        .prediction-card {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.2);
            transition: all 0.3s ease;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .prediction-number {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: -0.02em;
        }
        
        #categoryRank {
            font-size: 3.5rem;
            font-weight: 800;
            color: #ff0000;
            letter-spacing: -0.02em;
        }
        
        .prediction-label {
            color: #cccccc;
            font-size: 1.15rem;
            font-weight: 600;
            margin-top: 8px;
        }
        
        .btn-custom {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            border: none;
            color: #ffffff;
            padding: 15px 40px;
            border-radius: 12px;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 1.1rem;
            box-shadow: 0 8px 25px rgba(255, 0, 0, 0.3);
        }
        
        .btn-custom:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(255, 0, 0, 0.5);
        }
        
        .back-btn {
            background-color: #ff0000;
            border: 2px solid #ff0000;
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            background-color: transparent;
            color: #ff0000;
            transform: translateY(-2px);
        }
        
        .feature-icon {
            font-size: 3rem;
            color: #ff0000;
            margin-bottom: 1rem;
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
        }
        
        .step {
            display: flex;
            align-items: center;
            margin: 0 20px;
        }
        
        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.3);
            color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .step-number.completed {
            background-color: #ff0000;
        }
        
        .step-number.active {
            background-color: #ff0000;
        }
        
        .step-text {
            color: #ffffff;
            font-weight: 500;
        }
        
        .step-line {
            width: 50px;
            height: 2px;
            background-color: #ff0000;
            margin: 0 10px;
        }
        
        .footer {
            background-color: #000000;
            color: #ffffff;
            padding: 50px 0 20px;
            border-top: 3px solid #ff0000;
        }
        
        .video-info {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 15px;
            padding: 0;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.2);
            overflow: hidden;
        }
        
        .video-info-header {
            background-color: rgba(255, 0, 0, 0.1);
            border-bottom: 1px solid rgba(255, 0, 0, 0.3);
            padding: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .video-info-header:hover {
            background-color: rgba(255, 0, 0, 0.15);
        }
        
        .video-info-header h4 {
            color: #ffffff;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .video-info-header h4 i {
            color: #ff0000;
        }
        
        .video-info-toggle {
            color: #ff0000;
            font-size: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .video-info-toggle.expanded {
            transform: rotate(180deg);
        }
        
        .video-info-content {
            padding: 20px;
            display: none;
        }
        
        .video-info-content.show {
            display: block;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 0, 0, 0.2);
        }
        
        .info-item:last-child {
            border-bottom: none;
        }
        
        .info-label {
            font-weight: 600;
            color: #ffffff;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .info-label i {
            color: #ff0000;
        }
        
        .info-value {
            color: #cccccc;
        }
        
        .recommendation-item {
            background-color: rgba(0, 0, 0, 0.3);
            border-left: 4px solid #ff0000;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .recommendation-item:hover {
            background-color: rgba(255, 0, 0, 0.1);
            transform: translateX(5px);
            border-left-color: #ff0000;
        }
        
        .recommendation-title {
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 8px;
        }
        
        .recommendation-text {
            color: #cccccc;
            margin-bottom: 0;
        }
        
        .alert-success {
            background-color: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ffffff;
            border-radius: 12px;
        }
        
        .alert-warning {
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #ff0000;
            color: #ffffff;
            border-radius: 12px;
        }
        
        .text-muted {
            color: #cccccc !important;
        }
        
        .display-4 {
            color: #ffffff;
        }
        
        .lead {
            color: #cccccc;
        }
        
        h3, h5 {
            color: #ffffff;
        }
        
        .title-card {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }
        
        .title-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 0, 0, 0.3);
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .title-card .title-text {
            font-size: 1.1rem;
            font-weight: 500;
            color: #ffffff;
            flex-grow: 1;
            text-align: left;
        }
        
        .copy-btn {
            margin-left: 15px;
            background: transparent;
            border: 1px solid #ff0000;
            color: #ff0000;
            border-radius: 8px;
            padding: 8px 15px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .copy-btn:hover {
            background: #ff0000;
            color: white;
            border-color: #ff0000;
        }
        
        .card-header {
            background-color: transparent;
            border-bottom: 1px solid rgba(255, 0, 0, 0.3);
            padding: 20px;
        }
        
        .card-header h3 {
            color: #ffffff;
        }
        
        .form-control, .form-select {
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 0, 0, 0.3);
            border-radius: 12px;
            padding: 12px 15px;
            color: #ffffff;
        }
        
        .form-control:focus, .form-select:focus {
            background-color: rgba(0, 0, 0, 0.7);
            border-color: #ff0000;
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.15);
            color: #ffffff;
        }
        
        .btn-outline-danger {
            border: 2px solid #ff0000;
            color: #ff0000;
            background: transparent;
        }
        
        .btn-outline-danger:hover {
            background: #ff0000;
            color: #ffffff;
        }
        
        .card-body {
            padding: 20px;
        }
        
        #thumbnailPreview {
            border: 2px solid #ff0000;
        }
        
        .tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .tag-badge {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.2) 0%, rgba(255, 0, 0, 0.1) 100%);
            border: 1px solid rgba(255, 0, 0, 0.5);
            color: #ffffff;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .tag-badge:hover {
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.4) 0%, rgba(255, 0, 0, 0.2) 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 0, 0, 0.3);
        }
        
        .tag-badge.kept {
            border-color: rgba(0, 255, 0, 0.5);
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.2) 0%, rgba(0, 255, 0, 0.1) 100%);
        }
        
        .tag-badge.dropped {
            border-color: rgba(255, 100, 100, 0.3);
            background: linear-gradient(135deg, rgba(100, 100, 100, 0.2) 0%, rgba(100, 100, 100, 0.1) 100%);
            opacity: 0.6;
        }
        
        .tag-badge.final {
            border-color: rgba(255, 215, 0, 0.8);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.2) 100%);
            font-weight: 600;
        }
        
        .tag-badge.extra {
            border-color: rgba(0, 150, 255, 0.6);
            background: linear-gradient(135deg, rgba(0, 150, 255, 0.2) 0%, rgba(0, 150, 255, 0.1) 100%);
        }
        
        .tag-score {
            font-size: 0.75rem;
            color: #cccccc;
            opacity: 0.8;
        }
        
        .accordion-button {
            color: #ffffff !important;
        }
        
        .accordion-button:not(.collapsed) {
            background-color: rgba(255, 0, 0, 0.2) !important;
            color: #ffffff !important;
        }
        
        .accordion-button:focus {
            box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.25);
        }
        
        .alert-info {
            border-color: rgba(0, 150, 255, 0.3);
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <i class="bi bi-graph-up me-2"></i>
                1등 유튜버 되기
            </a>
            
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item"><a class="nav-link" href="index.html">홈</a></li>
                    <li class="nav-item"><a class="nav-link" href="index.html#features">주요 기능</a></li>
                    <li class="nav-item"><a class="nav-link" href="index.html#how-it-works">사용 방법</a></li>
                    <li class="nav-item"><a class="nav-link" href="index.html#key-features">핵심 특징</a></li>
                    <li class="nav-item"><a class="nav-link" href="trend.html">트렌드</a></li>
                    <li class="nav-item"><a class="nav-link" href="feedback.html">피드백</a></li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section class="hero-section" style="margin-top: 76px;">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-lg-8">
                    <a href="feedback.html" class="back-btn mb-4 d-inline-block">
                        <i class="bi bi-arrow-left me-2"></i>뒤로 가기
                    </a>
                    <h1 class="display-4 fw-bold mb-4" style="font-size: 3rem;">피드백 결과</h1>
                    <p class="lead mb-4" style="font-size: 1.25rem; font-weight: 400; line-height: 1.8;">구상한 영상 정보를 입력하면 AI가 조회수 예측과 개선 방향을 제안해드립니다.</p>
                </div>
                <div class="col-lg-4 text-center">
                    <i class="bi bi-graph-up-arrow feature-icon"></i>
                </div>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <div class="container" style="padding-bottom: 50px;">
        <!-- Step Indicator -->
        <div class="step-indicator">
            <div class="step">
                <div class="step-number completed">1</div>
                <div class="step-text">영상 정보 입력</div>
            </div>
            <div class="step-line"></div>
            <div class="step">
                <div class="step-number active">2</div>
                <div class="step-text">피드백 결과</div>
            </div>
        </div>

        <!-- Video Information Summary -->
        <div class="video-info">
            <div class="video-info-header" onclick="toggleVideoInfo()">
                <h4>
                    <i class="bi bi-info-circle"></i>
                    입력하신 영상 정보
                </h4>
                <i class="bi bi-chevron-down video-info-toggle" id="videoInfoToggle"></i>
            </div>
            <div class="video-info-content" id="videoInfoContent">
                <div id="videoInfoSummary">
                    <!-- Video info will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Prediction Results -->
        <div class="row g-4 mb-4 align-items-stretch">
            <div class="col-md-6 d-flex">
                <div class="prediction-card w-100">
                    <div class="prediction-number" id="predictedViews">0</div>
                    <div class="prediction-label">예상 조회수</div>
                    <div id="modelInfo" style="font-size: 0.85rem; color: #999999; margin-top: 12px; display: none;">
                        <small><i class="bi bi-info-circle me-2"></i><span id="modelInfoText"></span></small>
                    </div>
                </div>
            </div>
            <div class="col-md-6 d-flex">
                <div class="prediction-card w-100">
                    <div class="prediction-number" id="categoryRank">-</div>
                    <div id="categoryRankDesc" style="font-size: 0.85rem; color: #cccccc; margin-top: 8px; margin-bottom: 8px; display: none;"></div>
                    <div class="prediction-label">카테고리 순위</div>
                </div>
            </div>
        </div>

        <!-- Recommended Prediction Results -->
        <div class="row g-4 mb-4 align-items-stretch" id="recommendedPredictionSection" style="display: none;">
            <div class="col-12">
                <div class="feedback-card" style="border: 2px solid rgba(255, 193, 7, 0.5); background: linear-gradient(135deg, rgba(255, 193, 7, 0.05) 0%, rgba(255, 193, 7, 0.1) 100%);">
                    <div class="row align-items-center">
                        <div class="col-md-6 text-center">
                            <h4 class="mb-3" style="color: #ffc107; font-size: 1.5rem; font-weight: 700;">
                                <i class="bi bi-lightbulb-fill me-2"></i>피드백 적용시 예상 조회수
                            </h4>
                            <div class="prediction-number" id="recommendedViews" style="color: #ffc107; font-size: 3.5rem; font-weight: 800;">계산 중...</div>
                        </div>
                        <div class="col-md-6">
                            <div id="improvementStats" style="padding: 20px;">
                                <div class="mb-2">
                                    <strong style="color: #28a745; font-size: 1.1rem;">조회수 증가율:</strong>
                                    <span id="improvementPercent" style="color: #28a745; font-size: 1.75rem; font-weight: 700;">-</span>
                                </div>
                                <div class="mb-2">
                                    <strong style="color: #ffc107; font-size: 1.1rem;">예상 증가량:</strong>
                                    <span id="improvementAmount" style="color: #ffc107; font-size: 1.5rem; font-weight: 700;">-</span>
                                </div>
                                <p class="text-muted small mt-3">
                                    <i class="bi bi-info-circle me-1"></i>
                                    상세 피드백을 모두 따를 경우 예상되는 최대 조회수입니다.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Recommendations -->
        <div class="feedback-card">
            <h3 class="mb-4" style="color: #ff0000; font-size: 1.75rem; font-weight: 700;">상세 피드백</h3>
            
            <div class="row mb-4">
                <div class="col-12">
                    <div class="alert alert-success" style="background: rgba(40, 167, 69, 0.1); border: 1px solid rgba(40, 167, 69, 0.3); border-radius: 15px; padding: 20px;">
                        <h5 class="mb-3 d-flex align-items-center" style="color: #28a745; font-size: 1.3rem; font-weight: 700;">
                            <i class="bi bi-check-circle-fill me-2"></i>잘한 점
                        </h5>
                        <ul class="mb-0 ps-0" id="strengths" style="max-height: 400px; overflow-y: auto;">
                            <!-- Strengths will be populated by JavaScript -->
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="row mb-4">
                <div class="col-12">
                    <div class="alert alert-warning" style="background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.3); border-radius: 15px; padding: 20px;">
                        <h5 class="mb-3 d-flex align-items-center" style="color: #ffc107; font-size: 1.3rem; font-weight: 700;">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>개선점
                        </h5>
                        <div class="mb-4">
                            <div id="detailedRecommendations">
                                <!-- Detailed recommendations will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 제목 추천 섹션 -->
        <div class="feedback-card mt-5">
            <h3 class="mb-4" style="color: #ff0000; font-size: 1.75rem; font-weight: 700;">
                <i class="bi bi-pencil-square me-2"></i>제목 추천
            </h3>
            <p class="text-muted mb-4">구상한 영상 정보을 바탕으로 AI가 최적의 제목을 제안해드립니다.</p>
            <div class="card-body">
                <div id="titleLoading" class="text-center mt-4" style="display: none;">
                    <div class="spinner-border" style="color: #ff0000;" role="status">
                        <span class="visually-hidden">로딩 중...</span>
                    </div>
                    <p class="mt-3 text-muted">최적의 제목을 생성하고 있습니다...</p>
                </div>
                <div id="titleResults" style="display: none;">
                    <h5 class="fw-bold mb-3 text-white">
                        <i class="bi bi-check-circle me-2" style="color: #ff0000;"></i>추천 제목
                    </h5>
                    <div id="titleList"></div>
                    <div class="text-center mt-3">
                        <button class="btn btn-outline-danger" onclick="regenerateTitles()">
                            <i class="bi bi-arrow-clockwise me-2"></i>다른 제목 제안받기
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 태그 추천 섹션 -->
        <div class="feedback-card mt-5">
            <h3 class="mb-4" style="color: #ff0000; font-size: 1.75rem; font-weight: 700;">
                <i class="bi bi-tags me-2"></i>태그 추천
            </h3>
            <p class="text-muted mb-4">영상 제목을 바탕으로 AI가 최적의 태그를 추천해드립니다.</p>
            <div class="card-body">
                <!-- 현재 제목과 설명 표시 -->
                <div class="alert alert-info mb-4" style="background-color: rgba(0, 150, 255, 0.1); border-color: rgba(0, 150, 255, 0.3);">
                    <strong>분석 제목:</strong> <span id="currentTitleForTags" class="text-white"></span>
                    <br>
                    <strong>영상 설명:</strong> <span id="currentDescriptionForTags" class="text-white"></span>
                </div>
                
                <!-- 로딩 -->
                <div id="tagLoading" class="text-center mt-4" style="display: none;">
                    <div class="spinner-border" style="color: #ff0000;" role="status">
                        <span class="visually-hidden">로딩 중...</span>
                    </div>
                    <p class="mt-3 text-muted">AI가 태그를 분석하고 추천하고 있습니다...</p>
                </div>
                
                <!-- 태그 추천 결과 -->
                <div id="tagResults" style="display: none;">
                    <!-- 태그 추천 -->
                    <div class="mb-4">
                        <div class="d-flex align-items-center justify-content-between mb-3">
                            <h5 class="fw-bold mb-0 text-white">
                                <i class="bi bi-star-fill me-2" style="color: #ffd700;"></i>태그 추천
                            </h5>
                            <button class="btn btn-sm btn-outline-danger" onclick="copyAllTags()" title="모든 태그 복사">
                                <i class="bi bi-clipboard me-1"></i>전체 복사
                            </button>
                        </div>
                        <div class="alert alert-success" style="background-color: rgba(255, 215, 0, 0.1); border-color: rgba(255, 215, 0, 0.5);">
                            <div id="finalTags" class="tag-container"></div>
                        </div>
                    </div>
                    
                    <!-- 상세 분석 결과 (접을 수 있게) -->
                    <div class="accordion mb-4" id="tagAnalysisAccordion">
                        <div class="accordion-item" style="background-color: rgba(0, 0, 0, 0.3); border-color: rgba(255, 0, 0, 0.3);">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#tagAnalysisCollapse" style="background-color: rgba(0, 0, 0, 0.5); color: #ffffff;">
                                    <i class="bi bi-chevron-down me-2"></i>상세 분석 결과 보기
                                </button>
                            </h2>
                            <div id="tagAnalysisCollapse" class="accordion-collapse collapse" data-bs-parent="#tagAnalysisAccordion">
                                <div class="accordion-body">
                                    <!-- 후보 태그 -->
                                    <div class="mb-4">
                                        <h6 class="fw-bold mb-2 text-white">
                                            <i class="bi bi-list-ul me-2" style="color: #ff0000;"></i>모델 후보 태그
                                        </h6>
                                        <div id="candidateTags" class="tag-container"></div>
                                    </div>
                                    
                                    <!-- 유사도 점수 -->
                                    <div class="mb-4">
                                        <h6 class="fw-bold mb-2 text-white">
                                            <i class="bi bi-graph-up me-2" style="color: #ff0000;"></i>유사도 점수
                                        </h6>
                                        <div id="scoredTags" class="tag-container"></div>
                                    </div>
                                    
                                    <!-- 유지된 태그 -->
                                    <div class="mb-4">
                                        <h6 class="fw-bold mb-2 text-white">
                                            <i class="bi bi-check-circle me-2" style="color: #00ff00;"></i>유지된 태그
                                        </h6>
                                        <div id="keptTags" class="tag-container"></div>
                                    </div>
                                    
                                    <!-- 제외된 태그 -->
                                    <div class="mb-4">
                                        <h6 class="fw-bold mb-2 text-white">
                                            <i class="bi bi-x-circle me-2" style="color: #ff0000;"></i>제외된 태그
                                        </h6>
                                        <div id="droppedTags" class="tag-container"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="text-center mt-3">
                        <button class="btn btn-outline-danger me-2" onclick="generateNewTags()">
                            <i class="bi bi-arrow-clockwise me-2"></i>다시 추천받기
                        </button>
                        <button class="btn btn-outline-danger" onclick="copyAllTags()">
                            <i class="bi bi-clipboard me-2"></i>모든 태그 복사
                        </button>
                    </div>
                </div>
                
                <!-- 태그 추천 버튼 (초기 상태) -->
                <div id="tagGenerateButton" class="text-center mt-4">
                    <button class="btn btn-custom" onclick="generateTags()">
                        <i class="bi bi-magic me-2"></i>태그 추천받기
                    </button>
                    <p class="text-muted mt-2 small">제목을 바탕으로 AI가 최적의 태그를 추천해드립니다.</p>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="text-center mt-4">
            <button class="btn btn-custom btn-lg me-3" onclick="generateNewFeedback()">
                <i class="bi bi-arrow-clockwise me-2"></i>새로운 피드백
            </button>
            <button class="btn btn-custom btn-lg me-3" onclick="saveAnalysisResult()">
                <i class="bi bi-bookmark me-2"></i>분석 결과 저장
            </button>
            <button class="btn btn-custom btn-lg" onclick="downloadReport()">
                <i class="bi bi-download me-2"></i>보고서 다운로드
            </button>
        </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <p class="mb-0">&copy; 2024 1등 유튜버 되기. All rights reserved.</p>
                </div>
                <div class="col-md-6 text-md-end">
                    <a href="#" class="text-light text-decoration-none me-3">개인정보처리방침</a>
                    <a href="#" class="text-light text-decoration-none">이용약관</a>
                </div>
            </div>
        </div>
    </footer>

    <!-- Bootstrap 5 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Custom JavaScript -->
    <script>
        // API Base URL 설정 (Railway 배포 URL)
        const API_BASE = "https://youtube-production-ee6c.up.railway.app";
        // Category mapping
        const categoryMap = {
            '1': 'Film & Animation',
            '2': 'Autos & Vehicles',
            '10': 'Music',
            '15': 'Pets & Animals',
            '17': 'Sports',
            '18': 'Short Movies',
            '19': 'Travel & Events',
            '20': 'Gaming',
            '21': 'Videoblogging',
            '22': 'People & Blogs',
            '23': 'Comedy',
            '24': 'Entertainment',
            '25': 'News & Politics',
            '26': 'Howto & Style'
        };

        // 카테고리별 추천 기준 데이터 (예상 조회수 계산용)
        const categoryRecommendations = {
            '1': { // Film & Animation
                pub_hour: { min: 17.67, max: 18.0 }, // 시간 (0-23)
                pub_weekday: [3, 4, 5, 6], // 수(3), 목(4), 금(5), 토(6)
                pub_day: { min: 10, max: 26 }, // 일
                pub_month: { min: 1, max: 12 }, // 월 (추정, 기본값)
                duration_sec: { min: 235, max: 347 }, // 초 단위 (3분 55초 ~ 5분 47초)
                caption_available: 1, // 캡션 있음
                definition: 1, // HD
                subscriber_count: 4704358 // 90% 위치 값
            },
            '15': { // Pets & Animals
                pub_hour: { min: 15.08, max: 19.6 },
                pub_weekday: [1, 2, 3, 4, 5, 6, 0], // 월~일
                pub_day: { min: 7, max: 17 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 655, max: 1818 }, // 10분 55초 ~ 30분 18초
                caption_available: 0, // 캡션 없음
                definition: 1,
                subscriber_count: 0 // 범위 없음, 기본값 0
            },
            '19': { // Travel & Events
                pub_hour: { min: 0.0, max: 19.0 },
                pub_weekday: [1, 2, 3, 4, 5, 6, 0],
                pub_day: { min: 7, max: 19 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 1320, max: 3019 }, // 22분 0초 ~ 50분 19초
                caption_available: -1, // 둘다 가능 (사용자 선택)
                definition: 1,
                subscriber_count: 5111482
            },
            '17': { // Sports
                pub_hour: { min: 3.04, max: 23.39 },
                pub_weekday: [2, 3, 4, 5, 6, 0], // 화~일
                pub_day: { min: 9, max: 28 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 257, max: 1475 }, // 4분 17초 ~ 24분 35초
                caption_available: 1,
                definition: 1,
                subscriber_count: 15401877
            },
            '20': { // Gaming
                pub_hour: { min: 0.0, max: 20.79 },
                pub_weekday: [2, 3, 4, 5, 6, 0], // 화~일
                pub_day: { min: 1, max: 12 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 167, max: 2079 }, // 2분 47초 ~ 34분 39초
                caption_available: 1,
                definition: 1,
                subscriber_count: 14118548
            },
            '23': { // Comedy
                pub_hour: { min: 9.0, max: 9.57 },
                pub_weekday: [5, 6], // 금(5), 토(6)
                pub_day: { min: 14, max: 30 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 469, max: 4610 }, // 7분 49초 ~ 1시간 16분 50초
                caption_available: 1,
                definition: 1,
                subscriber_count: 3580453
            },
            '10': { // Music
                pub_hour: { min: 0.97, max: 21.07 },
                pub_weekday: [1, 2, 3, 4, 5, 6, 0],
                pub_day: { min: 8, max: 28 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 165, max: 210 }, // 2분 45초 ~ 3분 30초
                caption_available: 1,
                definition: 1,
                subscriber_count: 1530339
            },
            '22': { // People & Blogs
                pub_hour: { min: 14.41, max: 18.0 },
                pub_weekday: [2, 3, 4, 5, 6, 0], // 화~일
                pub_day: { min: 5, max: 28 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 190, max: 2773 }, // 3분 10초 ~ 46분 13초
                caption_available: 1,
                definition: 1,
                subscriber_count: 1599177
            },
            '24': { // Entertainment
                pub_hour: { min: 2.73, max: 21.0 },
                pub_weekday: [1, 2, 3, 4, 5, 6, 0], // 월~일
                pub_day: { min: 3, max: 27 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 196, max: 2340 }, // 3분 16초 ~ 39분 0초
                caption_available: -1, // 둘다 가능
                definition: 1,
                subscriber_count: 16403413
            },
            '26': { // Howto & Style
                pub_hour: { min: 3.0, max: 19.82 },
                pub_weekday: [2, 3, 4, 5, 6, 0], // 화~일
                pub_day: { min: 2, max: 29 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 360, max: 1043 }, // 6분 0초 ~ 17분 23초
                caption_available: -1, // 둘다 가능
                definition: 1,
                subscriber_count: 3109585
            },
            '28': { // 추가 카테고리
                pub_hour: { min: 0, max: 23 }, // 기본값
                pub_weekday: [1, 2, 3, 4, 5, 6, 0], // 기본값
                pub_day: { min: 1, max: 31 },
                pub_month: { min: 1, max: 12 },
                duration_sec: { min: 180, max: 3600 }, // 기본값
                caption_available: -1,
                definition: 1,
                subscriber_count: 0
            }
        };

        // 영상 길이 입력값 변환 함수
        // 지원 형식: "9시간 40분 5초", "40분 5초", "5초", "9시간", "2.5" (2분 5초), "10" (10분)
        function parseLengthInput(lengthStr) {
            if (!lengthStr) return 0;
            
            const str = String(lengthStr).trim();
            
            // 한글 형식 파싱: "9시간 40분 5초", "40분 5초", "5초", "9시간" 등
            const koreanPattern = /(?:(\d+)\s*시간\s*)?(?:(\d+)\s*분\s*)?(?:(\d+)\s*초\s*)?/;
            const match = str.match(koreanPattern);
            
            // 한글 단위(시간, 분, 초)가 포함되어 있는지 확인
            if (match && /[시간분초]/.test(str) && (match[1] || match[2] || match[3])) {
                const hours = parseInt(match[1] || 0) || 0;
                const minutes = parseInt(match[2] || 0) || 0;
                const seconds = parseInt(match[3] || 0) || 0;
                
                // 총 분으로 변환
                return hours * 60 + minutes + seconds / 60;
            }
            
            // 숫자 형식 파싱 (기존 로직 유지)
            const num = parseFloat(str);
            if (isNaN(num)) return 0;
            
            const parts = str.split('.');
            
            if (parts.length === 1) {
                // 정수만 있으면 그대로 반환 (예: "10" → 10분)
                return num;
            }
            
            // 소수 부분이 있으면
            const integerPart = parseInt(parts[0]) || 0;
            const decimalPart = parts[1];
            
            if (decimalPart) {
                const decimalInt = parseInt(decimalPart);
                // 소수 부분이 60 미만이면 초로 해석
                // 예: 2.5 → 2분 5초 → 2.083분
                // 예: 2.35 → 2분 35초 → 2.583분
                // 예: 80.58 → 80분 58초 → 80.967분 (1시간 20분 58초)
                if (decimalInt < 60) {
                    const seconds = decimalInt;
                    return integerPart + seconds / 60;
                }
            }
            
            // 그 외에는 기존 방식 (예: 2.60 → 2.60분)
            return num;
        }
        
        // 분 값을 "시간 분 초" 형식 문자열로 변환하는 함수
        function formatLengthDisplay(lengthStr) {
            if (!lengthStr) return '0분';
            
            // 먼저 parseLengthInput으로 변환
            const lengthInMinutes = parseLengthInput(lengthStr);
            
            // 총 초로 변환
            const totalSeconds = Math.round(lengthInMinutes * 60);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // 표시 형식 반환
            const parts = [];
            if (hours > 0) parts.push(`${hours}시간`);
            if (minutes > 0) parts.push(`${minutes}분`);
            if (seconds > 0 || parts.length === 0) parts.push(`${seconds}초`);
            
            return parts.join(' ');
        }

        // Load video data and generate feedback
        document.addEventListener('DOMContentLoaded', function() {
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
            const predictionResult = JSON.parse(sessionStorage.getItem('predictionResult'));
            
            if (!videoData) {
                alert('영상 정보가 없습니다. 다시 입력해주세요.');
                window.location.href = 'feedback.html';
                return;
            }
            
            // Display video information
            displayVideoInfo(videoData);
            
            // Initialize upload time selectors
            initializeUploadTimeSelectors(videoData);
            
            // Display thumbnail if available
            if (videoData.thumbnailImage) {
                const thumbnailDisplay = document.getElementById('thumbnailDisplay');
                const thumbnailPreview = document.getElementById('thumbnailPreview');
                thumbnailPreview.src = videoData.thumbnailImage;
                thumbnailDisplay.style.display = 'block';
            }
            
            // Display prediction results - 무조건 실제 모델 예측만 사용
            if (predictionResult && 
                typeof predictionResult.predicted_views === 'number' && 
                predictionResult.predicted_views > 0 &&
                !predictionResult.model_used?.includes('Simulated') &&
                !predictionResult.model_used?.includes('Unknown')) {
                console.log('실제 예측 결과 있음:', predictionResult);
                displayPredictionResults(predictionResult);
            } else {
                // 실제 예측 결과가 없으면 API 호출로 다시 예측
                console.log('예측 결과 없음, 실제 모델로 예측 수행:', videoData);
                fetchRealPrediction(videoData);
            }
            
            
            // Generate recommendations
            generateRecommendations(videoData, predictionResult);
            
            // Auto-generate titles (자동으로 제목 생성)
            setTimeout(() => {
            autoGenerateTitles(videoData);
            }, 1000); // 1초 후에 제목 생성 시작
            
            // Auto-generate tags (자동으로 태그 추천)
            setTimeout(() => {
                autoGenerateTags(videoData);
            }, 3000); // 3초 후에 태그 추천 시작
            
        });
        
        function displayVideoInfo(data) {
            const summaryDiv = document.getElementById('videoInfoSummary');
            summaryDiv.innerHTML = `
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-film"></i>
                        영상 제목
                    </span>
                    <span class="info-value">${data.title || '입력되지 않음'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-tags"></i>
                        카테고리
                    </span>
                    <span class="info-value">${categoryMap[data.category] || '선택되지 않음'}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-clock"></i>
                        영상 길이
                    </span>
                    <span class="info-value">${formatLengthDisplay(data.length)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-calendar-event"></i>
                        업로드 예정 시간
                    </span>
                    <span class="info-value">
                        <div class="d-flex gap-2 flex-wrap align-items-center" style="flex-wrap: wrap;">
                            <select id="uploadMonthResult" class="form-control" style="background-color: #1a1a1a; border: 1px solid rgba(255, 0, 0, 0.3); color: #ffffff; width: auto; min-width: 70px; padding: 5px 10px;" onchange="updateUploadTimeFromSelectors()" onclick="event.stopPropagation();"></select>
                            <span style="color: #cccccc;">월</span>
                            <select id="uploadDayResult" class="form-control" style="background-color: #1a1a1a; border: 1px solid rgba(255, 0, 0, 0.3); color: #ffffff; width: auto; min-width: 70px; padding: 5px 10px;" onchange="updateUploadTimeFromSelectors()" onclick="event.stopPropagation();"></select>
                            <span style="color: #cccccc;">일</span>
                            <select id="uploadDayOfWeekResult" class="form-control" style="background-color: #1a1a1a; border: 1px solid rgba(255, 0, 0, 0.3); color: #ffffff; width: auto; min-width: 90px; padding: 5px 10px;" onchange="updateUploadTimeFromSelectors()" onclick="event.stopPropagation();">
                                <option value="0">일요일</option>
                                <option value="1">월요일</option>
                                <option value="2">화요일</option>
                                <option value="3">수요일</option>
                                <option value="4">목요일</option>
                                <option value="5">금요일</option>
                                <option value="6">토요일</option>
                            </select>
                            <select id="uploadHourResult" class="form-control" style="background-color: #1a1a1a; border: 1px solid rgba(255, 0, 0, 0.3); color: #ffffff; width: auto; min-width: 70px; padding: 5px 10px;" onchange="updateUploadTimeFromSelectors()" onclick="event.stopPropagation();"></select>
                            <span style="color: #cccccc;">시</span>
                        </div>
                    </span>
                </div>
                ${data.description ? `
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-card-text"></i>
                        영상 설명
                    </span>
                    <span class="info-value">${data.description.substring(0, 50)}${data.description.length > 50 ? '...' : ''}</span>
                </div>
                ` : ''}
                ${data.thumbnailImage ? `
                <div class="info-item">
                    <span class="info-label">
                        <i class="bi bi-image"></i>
                        썸네일 이미지
                    </span>
                    <span class="info-value">업로드됨</span>
                </div>
                ` : ''}
            `;
        }
        
        // Toggle video info accordion
        function toggleVideoInfo() {
            const content = document.getElementById('videoInfoContent');
            const toggle = document.getElementById('videoInfoToggle');
            
            content.classList.toggle('show');
            toggle.classList.toggle('expanded');
        }
        
        // 업로드 예정 시간 선택자 초기화
        function initializeUploadTimeSelectors(data) {
            if (!data.uploadTime) return;
            
            const date = new Date(data.uploadTime);
            const currentYear = new Date().getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours();
            const dayOfWeek = date.getDay(); // 0 = 일요일, 6 = 토요일
            
            // 월 옵션
            const monthSelect = document.getElementById('uploadMonthResult');
            monthSelect.innerHTML = '';
            for (let i = 1; i <= 12; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                monthSelect.appendChild(option);
            }
            monthSelect.value = month;
            
            // 일 옵션 업데이트
            function updateDaysResult() {
                const year = currentYear;
                const month = parseInt(document.getElementById('uploadMonthResult').value);
                const daySelect = document.getElementById('uploadDayResult');
                const currentDay = parseInt(daySelect.value) || day;
                
                const lastDay = new Date(year, month, 0).getDate();
                daySelect.innerHTML = '';
                for (let i = 1; i <= lastDay; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = i;
                    daySelect.appendChild(option);
                }
                daySelect.value = currentDay > lastDay ? lastDay : currentDay;
                updateDayOfWeekResult();
            }
            
            // 요일 업데이트 함수
            function updateDayOfWeekResult() {
                const year = currentYear;
                const month = parseInt(document.getElementById('uploadMonthResult').value);
                const day = parseInt(document.getElementById('uploadDayResult').value);
                const date = new Date(year, month - 1, day);
                const dayOfWeek = date.getDay();
                document.getElementById('uploadDayOfWeekResult').value = dayOfWeek;
                updateUploadTimeFromSelectors();
            }
            
            document.getElementById('uploadMonthResult').addEventListener('change', function() {
                updateDaysResult();
            });
            document.getElementById('uploadDayResult').addEventListener('change', updateDayOfWeekResult);
            
            updateDaysResult();
            document.getElementById('uploadDayResult').value = day;
            document.getElementById('uploadDayOfWeekResult').value = dayOfWeek;
            
            // 시간 옵션 (0-23)
            const hourSelect = document.getElementById('uploadHourResult');
            hourSelect.innerHTML = '';
            for (let i = 0; i <= 23; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                hourSelect.appendChild(option);
            }
            hourSelect.value = hours;
            
            updateUploadTimeFromSelectors();
        }
        
        // 선택자에서 업로드 예정 시간 업데이트
        function updateUploadTimeFromSelectors() {
            const year = new Date().getFullYear(); // 현재 년도 사용
            const month = document.getElementById('uploadMonthResult').value.padStart(2, '0');
            const day = document.getElementById('uploadDayResult').value.padStart(2, '0');
            const hour = parseInt(document.getElementById('uploadHourResult').value);
            const hourStr = hour.toString().padStart(2, '0');
            
            // datetime-local 형식으로 조합
            const dateTimeValue = `${year}-${month}-${day}T${hourStr}:00`;
            updateUploadTime(dateTimeValue);
        }
        
        // 업로드 예정 시간 업데이트 함수 - 실제 모델로 다시 예측
        async function updateUploadTime(newTime) {
            if (!newTime) return;
            
            // videoData 업데이트
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
            if (!videoData) return;
            
            videoData.uploadTime = newTime;
            sessionStorage.setItem('videoData', JSON.stringify(videoData));
            
            // 실제 모델로 다시 예측 (API 호출)
            try {
                const sessionToken = localStorage.getItem('session_token');
                let url = `${API_BASE}/api/videos/create`;
                if (sessionToken) {
                    url += `?session_token=${sessionToken}`;
                }
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: videoData.title,
                        category: videoData.category,
                        length: parseLengthInput(videoData.length),
                        upload_time: newTime,
                        description: videoData.description || '',
                        thumbnail_image: videoData.thumbnailImage || '',
                        has_subtitles: videoData.hasSubtitles !== undefined ? videoData.hasSubtitles : false,
                        video_quality: videoData.videoQuality || 'HD',
                        subscriber_count: videoData.subscriberCount || 0
                    })
                });
                
                if (response.ok) {
                    const saveData = await response.json();
                    if (saveData.data && saveData.data.prediction) {
                        const predictionResult = {
                            predicted_views: saveData.data.prediction.predicted_views,
                            pred_popular_prob: saveData.data.prediction.pred_popular_prob,
                            confidence: saveData.data.prediction.confidence,
                            cls_model: saveData.data.prediction.cls_model || 'Unknown',
                            reg_model: saveData.data.prediction.reg_model || 'Unknown',
                            cls_model_file: saveData.data.prediction.cls_model_file || '',
                            reg_model_file: saveData.data.prediction.reg_model_file || '',
                            model_type: saveData.data.prediction.model_type || 'unknown',
                            model_used: `${saveData.data.prediction.cls_model || 'Unknown'} + ${saveData.data.prediction.reg_model || 'Unknown'}`
                        };
                        sessionStorage.setItem('predictionResult', JSON.stringify(predictionResult));
                        
                        // 카테고리 순위 정보 가져오기
                        const categoryRankInfo = getCategoryRankStatus(videoData.category);
                        const isTrendCategory = categoryRankInfo.inTop5;
                        
                        // 구독자 수 가져오기
                        const subscriberCount = videoData.subscriberCount || 0;
                        
                        // 예측 조회수 조정 (구독자 수와 트렌드/비트렌드 카테고리 기준)
                        const adjustedViews = adjustPredictedViews(predictionResult.predicted_views, subscriberCount, isTrendCategory);
                        
                        // 예상 조회수 업데이트 (조정된 값)
                        animateNumber('predictedViews', adjustedViews, '');
                        
                        // 카테고리 순위 업데이트
                        document.getElementById('categoryRank').textContent = categoryRankInfo.display;
                        const descElement = document.getElementById('categoryRankDesc');
                        if (categoryRankInfo.desc) {
                            descElement.textContent = categoryRankInfo.desc;
                            descElement.style.display = 'block';
                        } else {
                            descElement.style.display = 'none';
                        }
                        
                        // 모델 정보 업데이트
                        displayPredictionResults(predictionResult);
                        
                        // 예측 결과가 준비되었으므로 "완벽합니다" 체크 다시 수행
                        const originalCategoryFeedback = generateCategoryBasedFeedback(videoData);
                        calculateRecommendedPrediction(videoData, originalCategoryFeedback, predictionResult);
                    }
                }
            } catch (error) {
                console.error('예측 재계산 실패:', error);
                // 실패해도 기존 값 유지
            }
        }
        
        function displayPredictionResults(result) {
            // Display category rank status
            // videoData에서 카테고리 정보를 찾아서 다시 계산
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
            let categoryRankInfo;
            if (videoData && videoData.category) {
                categoryRankInfo = getCategoryRankStatus(videoData.category);
            } else {
                categoryRankInfo = {
                    display: 'X',
                    desc: '2025년 상반기 상위 30% 인기 카테고리 아님',
                    inTop5: false
                };
            }
            
            // 구독자 수와 트렌드/비트렌드 카테고리 정보 가져오기
            const isTrendCategory = categoryRankInfo.inTop5;
            const subscriberCount = (videoData && videoData.subscriberCount) ? videoData.subscriberCount : 0;
            
            // 예측 조회수 조정 (구독자 수와 트렌드/비트렌드 카테고리 기준)
            const adjustedViews = adjustPredictedViews(result.predicted_views, subscriberCount, isTrendCategory);
            
            // Display predicted views (조정된 값)
            animateNumber('predictedViews', adjustedViews, '');
            
            document.getElementById('categoryRank').textContent = categoryRankInfo.display;
            
            // 설명 표시
            const descElement = document.getElementById('categoryRankDesc');
            if (categoryRankInfo.desc) {
                descElement.textContent = categoryRankInfo.desc;
                descElement.style.display = 'block';
            } else {
                descElement.style.display = 'none';
            }
            
            // 모델 정보를 "예상 조회수" 아래에만 표시 (위에 표시 제거)
            const modelInfoElement = document.getElementById('modelInfo');
            const modelInfoTextElement = document.getElementById('modelInfoText');
            
            // 아래쪽 모델 정보 (상세 정보)
            if (result.cls_model_file && result.reg_model_file) {
                if (modelInfoTextElement) {
                    modelInfoTextElement.innerHTML = `<strong>사용된 모델:</strong><br>• 분류: ${result.cls_model_file}<br>• 회귀: ${result.reg_model_file}`;
                }
                if (modelInfoElement) {
                    modelInfoElement.style.display = 'block';
                }
            } else if (result.cls_model && result.reg_model && 
                       result.cls_model !== 'Unknown' && result.reg_model !== 'Unknown') {
                if (modelInfoTextElement) {
                    modelInfoTextElement.innerHTML = `<strong>사용된 모델:</strong> ${result.cls_model} + ${result.reg_model}`;
                }
                if (modelInfoElement) {
                    modelInfoElement.style.display = 'block';
                }
            } else {
                if (modelInfoElement) {
                    modelInfoElement.style.display = 'none';
                }
            }
            
            // localStorage에 저장 (이미 저장되어 있지만 확실히 하기 위해)
            localStorage.setItem('predictionResult', JSON.stringify(result));
        }
        
        // 실제 모델로 예측 수행 (무조건 pkl 모델만 사용)
        async function fetchRealPrediction(data) {
            try {
                console.log('🔍 fetchRealPrediction 시작:', data);
                
                const sessionToken = localStorage.getItem('session_token');
                let url = `${API_BASE}/api/videos/create`;
                if (sessionToken) {
                    url += `?session_token=${sessionToken}`;
                }
                
                const requestBody = {
                    title: data.title,
                    category: data.category,
                    length: parseLengthInput(data.length),
                    upload_time: data.uploadTime,
                    description: data.description || '',
                    thumbnail_image: data.thumbnailImage || '',
                    has_subtitles: data.hasSubtitles !== undefined ? data.hasSubtitles : false,
                    video_quality: data.videoQuality || 'HD',
                    subscriber_count: data.subscriberCount || 0
                };
                
                console.log('📤 API 요청:', url, requestBody);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('📥 API 응답 상태:', response.status, response.statusText);
                
                if (response.ok) {
                    const saveData = await response.json();
                    console.log('📥 API 응답 데이터:', saveData);
                    console.log('📥 saveData.data:', saveData.data);
                    console.log('📥 saveData.data.prediction:', saveData.data ? saveData.data.prediction : '없음');
                    
                    if (saveData.success && saveData.data) {
                        // prediction이 없거나 null인 경우
                        if (!saveData.data.prediction || saveData.data.prediction === null) {
                            console.error('❌ 예측 결과가 없습니다 (백엔드에서 예측 실패)');
                            console.error('전체 응답:', JSON.stringify(saveData, null, 2));
                            alert('조회수 예측에 실패했습니다.\n\n백엔드 서버 로그를 확인해주세요.\n(서버 콘솔에서 "⚠️ 조회수 예측 실패" 메시지 확인)');
                            return;
                        }
                        
                        const predictionResult = {
                            predicted_views: saveData.data.prediction.predicted_views,
                            pred_popular_prob: saveData.data.prediction.pred_popular_prob,
                            confidence: saveData.data.prediction.confidence,
                            cls_model: saveData.data.prediction.cls_model || 'Unknown',
                            reg_model: saveData.data.prediction.reg_model || 'Unknown',
                            cls_model_file: saveData.data.prediction.cls_model_file || '',
                            reg_model_file: saveData.data.prediction.reg_model_file || '',
                            model_type: saveData.data.prediction.model_type || 'unknown',
                            model_used: `${saveData.data.prediction.cls_model || 'Unknown'} + ${saveData.data.prediction.reg_model || 'Unknown'}`
                        };
                        sessionStorage.setItem('predictionResult', JSON.stringify(predictionResult));
                        console.log('✅ 실제 모델 예측 완료:', predictionResult);
                        
                        // 예측 결과 표시
                        displayPredictionResults(predictionResult);
                        
                        // 예측 결과가 준비되었으므로 "완벽합니다" 체크 다시 수행
                        const originalCategoryFeedback = generateCategoryBasedFeedback(data);
                        calculateRecommendedPrediction(data, originalCategoryFeedback, predictionResult);
                    } else {
                        console.error('❌ 응답 구조 오류');
                        console.error('saveData.success:', saveData.success);
                        console.error('saveData.data:', saveData.data);
                        alert('조회수 예측에 실패했습니다. 응답 구조가 올바르지 않습니다.');
                    }
                } else {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        console.error('❌ API 에러 응답:', errorData);
                        errorMessage = errorData.detail || errorData.message || errorMessage;
                    } catch (e) {
                        console.error('❌ 에러 응답 JSON 파싱 실패:', e);
                        const errorText = await response.text();
                        console.error('❌ 에러 응답 텍스트:', errorText);
                    }
                    console.error('❌ API 호출 실패:', errorMessage);
                    alert(`조회수 예측에 실패했습니다: ${errorMessage}`);
                }
            } catch (error) {
                console.error('❌ 예측 실패 (예외 발생):', error);
                console.error('❌ 에러 스택:', error.stack);
                alert(`조회수 예측 중 오류가 발생했습니다: ${error.message}\n\n콘솔을 확인해주세요.`);
            }
        }
        
        // 카테고리 순위 상태 확인 함수 (현재 월 기준)
        function getCategoryRankStatus(categoryId) {
            // 현재 월 구하기
            const now = new Date();
            const currentMonth = now.getMonth() + 1; // 1-12
            const currentMonthKey = `${currentMonth}월`;
            
            // localStorage에서 최신 트렌드 데이터 가져오기
            let trendData = null;
            try {
                const storedTrendData = localStorage.getItem('trendData');
                if (storedTrendData) {
                    trendData = JSON.parse(storedTrendData);
                }
            } catch (e) {
                console.error('트렌드 데이터 파싱 실패:', e);
            }
            
            // 기본값 (1-10월 하드코딩된 TOP 5) - 업데이트 버튼이 안 눌렸을 때 사용
            const defaultTop5 = {
                '1월': ['24', '22', '23', '19', '10'],
                '2월': ['24', '22', '26', '19', '10'],
                '3월': ['22', '24', '23', '10', '26'],
                '4월': ['22', '24', '10', '23', '26'],
                '5월': ['24', '22', '10', '19', '23'],
                '6월': ['22', '24', '10', '23', '26'],
                '7월': ['24', '10', '22', '20', '26'],
                '8월': ['10', '20', '24', '1', '22'],
                '9월': ['10', '20', '24', '1', '22'],
                '10월': ['10', '20', '24', '1', '22']
            };
            
            // 현재 월의 TOP 5 카테고리 가져오기
            let currentMonthTop5 = [];
            
            // 1-10월: 기본값 사용
            if (currentMonth >= 1 && currentMonth <= 10) {
                currentMonthTop5 = defaultTop5[currentMonthKey] || [];
            } else {
                // 11-12월: localStorage의 트렌드 데이터 사용
                if (trendData && trendData[currentMonthKey] && Array.isArray(trendData[currentMonthKey]) && trendData[currentMonthKey].length > 0) {
                    currentMonthTop5 = trendData[currentMonthKey].map(id => String(id));
                } else {
                    currentMonthTop5 = [];
                }
            }
            
            // 현재 월의 데이터가 있는지 확인
            if (currentMonthTop5.length === 0) {
                return {
                    display: '데이터 없음',
                    desc: `${currentMonth}월 트렌드 데이터가 없습니다.`,
                    inTop5: false
                };
            }
            
            // 현재 월에서 카테고리의 순위 찾기
            const rank = currentMonthTop5.indexOf(String(categoryId)) + 1; // 1-5 또는 0 (없으면)
            
            if (rank > 0) {
                return {
                    display: `${rank}위`,
                    desc: `${currentMonth}월 기준`,
                    inTop5: true
                };
            } else {
                return {
                    display: '순위 없음',
                    desc: `${currentMonth}월 트렌드 TOP 5에 포함되지 않음`,
                    inTop5: false
                };
            }
        }
        
        // 구독자 수와 트렌드/비트렌드 카테고리에 따라 예측 조회수 조정 함수
        function adjustPredictedViews(predictedViews, subscriberCount, isTrendCategory) {
            // 구독자 수 범위 확인
            if (subscriberCount <= 100) {
                // 100 이하
                return Math.round(predictedViews * (isTrendCategory ? 0.005 : 0.001));
            } else if (subscriberCount >= 100 && subscriberCount <= 999) {
                // 백 단위 (100~999)
                return Math.round(predictedViews * (isTrendCategory ? 0.05 : 0.01));
            } else if (subscriberCount >= 1000 && subscriberCount <= 9999) {
                // 천 단위 (1,000~9,999)
                return Math.round(predictedViews * (isTrendCategory ? 0.4 : 0.2));
            } else if (subscriberCount >= 10000 && subscriberCount <= 99999) {
                // 만 단위 (10,000~99,999)
                return Math.round(predictedViews * (isTrendCategory ? 0.5 : 0.25));
            } else if (subscriberCount >= 100000 && subscriberCount <= 1000000) {
                // 십만 단위 (100,000~1,000,000)
                return Math.round(predictedViews * (isTrendCategory ? 1.0 : 0.95));
            } else {
                // 그 외의 경우 (1,000,000 이상) 원래 값 그대로
                return Math.round(predictedViews);
            }
        }
        
        // 헬퍼 함수들 추가
        function generateRecommendationsText(data, predictedViews, confidence) {
            const recommendations = [];
            
            if (predictedViews > 1000000) {
                recommendations.push("높은 조회수 예상! 현재 전략을 유지하세요.");
            } else if (predictedViews > 500000) {
                recommendations.push("좋은 조회수 예상. 제목과 썸네일을 최적화해보세요.");
            } else {
                recommendations.push("조회수 향상을 위해 콘텐츠 전략을 재검토해보세요.");
            }
            
            const videoLengthForCheck = parseLengthInput(data.length);
            if (videoLengthForCheck > 20) {
                recommendations.push("영상 길이가 길어 시청자 이탈이 있을 수 있습니다.");
            }
            
            if (confidence < 80) {
                recommendations.push("예측 신뢰도가 낮습니다. 더 많은 데이터가 필요할 수 있습니다.");
            }
            
            return recommendations;
        }
        
        function generateCategoryAnalysis(category) {
            const categoryNames = {
                '1': 'Film & Animation',
                '2': 'Autos & Vehicles',
                '10': 'Music',
                '15': 'Pets & Animals',
                '17': 'Sports',
                '18': 'Short Movies',
                '19': 'Travel & Events',
                '20': 'Gaming',
                '21': 'Videoblogging',
                '22': 'People & Blogs',
                '23': 'Comedy',
                '24': 'Entertainment',
                '25': 'News & Politics',
                '26': 'Howto & Style'
            };
            
            const categoryName = categoryNames[category] || '기타';
            return `${categoryName} 카테고리에서 경쟁력 있는 콘텐츠입니다.`;
        }
        
        async function generateTitleSuggestions(data) {
            try {
                // 노트북의 제목 추천 함수 사용
                const keyword = data.title;
                const imageText = data.description || '';
                const titles = await generateYouTubeTitles(keyword, imageText, 5);
                
                // 제목을 배열로 파싱
                const titleArray = titles.split('\n')
                    .map(title => title.replace(/^\d+[\.\)]\s*/, '').trim())
                    .filter(title => title.length > 0)
                    .slice(0, 5);
                
                return titleArray;
            } catch (error) {
                console.error("Error generating title suggestions:", error);
                // 오류 시 기본 제목들 반환
                const baseTitle = data.title;
                const category = getCategoryName(data.category);
                
                return [
                    `${baseTitle} | ${category} 최신 트렌드`,
                    `🔥 ${baseTitle} - 놓치면 후회하는 내용`,
                    `${baseTitle} 완벽 가이드 | 초보자도 쉽게 따라하기`,
                    `[${category}] ${baseTitle} - 전문가가 알려주는 비법`,
                    `${baseTitle} | 2024년 최신 정보 총정리`
                ];
            }
        }
        
        
        function animateNumber(elementId, targetValue, suffix) {
            const element = document.getElementById(elementId);
            let currentValue = 0;
            const increment = targetValue / 100;
            const timer = setInterval(() => {
                currentValue += increment;
                if (currentValue >= targetValue) {
                    element.textContent = Math.floor(targetValue).toLocaleString() + suffix;
                    clearInterval(timer);
                } else {
                    element.textContent = Math.floor(currentValue).toLocaleString() + suffix;
                }
            }, 20);
        }
        
        // 업로드 시간을 시:분 형식으로 변환하는 함수 (예: 18.5 → 18시 30분)
        function formatUploadTime(timeValue) {
            const hours = Math.floor(timeValue); // 시
            const decimalPart = timeValue - hours; // 소수점 부분
            const minutes = Math.round(decimalPart * 60); // 분으로 변환
            
            if (minutes === 0) {
                return `${hours}시`;
            } else {
                return `${hours}시 ${minutes}분`;
            }
        }
        
        // 카테고리별 기준과 비교하여 피드백 생성
        function generateCategoryBasedFeedback(data) {
            const category = data.category;
            const recommendations = categoryRecommendations[category];
            
            if (!recommendations) {
                return {
                    strengths: [],
                    improvements: [],
                    detailedRecommendations: []
                };
            }

            const strengths = [];
            const improvements = [];
            const detailedRecommendations = [];

            // 1. 시간(업로드 시간) 검사
            if (data.uploadTime && recommendations.pub_hour) {
                const uploadDate = new Date(data.uploadTime);
                const uploadHour = uploadDate.getHours() + uploadDate.getMinutes() / 60;
                
                // 업로드 시간은 시:분 형식으로 표시
                const minTimeStr = formatUploadTime(recommendations.pub_hour.min);
                const maxTimeStr = formatUploadTime(recommendations.pub_hour.max);
                const currentTimeStr = formatUploadTime(uploadHour);
                
                if (uploadHour >= recommendations.pub_hour.min && uploadHour <= recommendations.pub_hour.max) {
                    strengths.push(`업로드 시간이 이 카테고리의 최적 시간대(${minTimeStr} ~ ${maxTimeStr})에 포함됩니다.`);
                } else {
                    const improvementText = `업로드 시간을 ${minTimeStr} ~ ${maxTimeStr} 사이로 조정하시는 것을 권장합니다. 이 시간대는 이 카테고리의 인기 영상들이 가장 많이 업로드되고, 시청자들의 활동이 활발한 시간입니다. 이 시간에 업로드하면 알고리즘에 노출될 가능성이 높아지고, 시청자들이 가장 많이 YouTube를 사용하는 시간대와 맞춰져 자연스럽게 더 많은 조회수를 얻을 수 있습니다.`;
                    detailedRecommendations.push({
                        type: 'time',
                        current: currentTimeStr,
                        recommended: `${minTimeStr} ~ ${maxTimeStr}`,
                        description: improvementText
                    });
                }
            }

            // 2. 요일 검사
            if (data.uploadTime && recommendations.pub_weekday) {
                const uploadDate = new Date(data.uploadTime);
                const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
                const currentDayIndex = uploadDate.getDay();
                const currentDay = dayNames[currentDayIndex];
                
                if (recommendations.pub_weekday.includes(currentDayIndex)) {
                    strengths.push(`업로드 요일(${currentDay}요일)이 이 카테고리에 적합합니다.`);
                } else {
                    const recommendedDays = recommendations.pub_weekday.map(idx => dayNames[idx]);
                    const improvementText = `업로드 요일을 ${recommendedDays.join(', ')}요일 중 하나로 선택하시는 것을 권장합니다. 이 요일들은 이 카테고리의 인기 영상들이 가장 많이 업로드되는 요일이며, 해당 카테고리 시청자들이 YouTube를 가장 많이 이용하는 요일입니다. 이러한 요일에 업로드하면 경쟁 영상 대비 상대적으로 더 많은 노출 기회를 얻을 수 있고, 시청자들의 관심을 받기 좋은 타이밍입니다.`;
                    detailedRecommendations.push({
                        type: 'day',
                        current: `${currentDay}요일`,
                        recommended: recommendedDays.join(', ') + '요일',
                        description: improvementText
                    });
                }
            }

            // 3. 날짜(월의 일) 검사
            if (data.uploadTime && recommendations.pub_day) {
                const uploadDate = new Date(data.uploadTime);
                const dayOfMonth = uploadDate.getDate();
                
                if (dayOfMonth >= recommendations.pub_day.min && dayOfMonth <= recommendations.pub_day.max) {
                    strengths.push(`업로드 날짜(${dayOfMonth}일)가 이 카테고리의 최적 기간(${recommendations.pub_day.min}일 ~ ${recommendations.pub_day.max}일)에 포함됩니다.`);
                } else {
                    const improvementText = `업로드 날짜를 ${recommendations.pub_day.min}일 ~ ${recommendations.pub_day.max}일 사이로 조정하시는 것을 권장합니다. 월 중 이 기간에는 이 카테고리의 인기 영상들이 가장 많이 업로드되며, 시청자들의 관심이 집중되는 시기입니다. 또한 이 기간에 업로드하면 알고리즘이 콘텐츠를 추천하는 데 유리한 위치에 놓일 수 있으며, 시청자들의 탐색 패턴과 맞춰져 더 나은 성과를 얻을 수 있습니다.`;
                    detailedRecommendations.push({
                        type: 'date',
                        current: `${dayOfMonth}일`,
                        recommended: `${recommendations.pub_day.min}일 ~ ${recommendations.pub_day.max}일`,
                        description: improvementText
                    });
                }
            }

            // 4. 영상 길이 검사
            if (recommendations.duration_sec) {
                const videoLengthSeconds = (parseLengthInput(data.length) || 0) * 60; // 분을 초로 변환
                const currentMin = Math.floor(videoLengthSeconds / 60);
                const currentSec = videoLengthSeconds % 60;
                // 잘한점/개선점 텍스트에서는 formatLengthDisplay 사용 (이미 시간/분/초 형식 포함)
                const currentLengthStr = formatLengthDisplay(data.length);
                
                if (videoLengthSeconds >= recommendations.duration_sec.min && videoLengthSeconds <= recommendations.duration_sec.max) {
                    const minMin = Math.floor(recommendations.duration_sec.min / 60);
                    const minSec = recommendations.duration_sec.min % 60;
                    const maxMin = Math.floor(recommendations.duration_sec.max / 60);
                    const maxSec = recommendations.duration_sec.max % 60;
                    strengths.push(`영상 길이가 이 카테고리의 최적 길이(${minMin}분 ${minSec}초 ~ ${maxMin}분 ${maxSec}초)에 적합합니다.`);
                } else {
                    const minMin = Math.floor(recommendations.duration_sec.min / 60);
                    const minSec = recommendations.duration_sec.min % 60;
                    const maxMin = Math.floor(recommendations.duration_sec.max / 60);
                    const maxSec = recommendations.duration_sec.max % 60;
                    const isTooShort = videoLengthSeconds < recommendations.duration_sec.min;
                    const isTooLong = videoLengthSeconds > recommendations.duration_sec.max;
                    let reasonText = '';
                    
                    if (isTooShort) {
                        reasonText = `현재 영상 길이(${currentLengthStr})가 이 카테고리의 추천 길이보다 짧습니다. 짧은 영상은 여러 가지 이유로 추천하지 않습니다: 첫째, 시청자들에게 충분한 콘텐츠 가치를 제공하지 못하여 만족도가 떨어질 수 있습니다. 둘째, YouTube 알고리즘은 시청 시간(Average View Duration)을 중요한 지표로 사용하는데, 짧은 영상은 전체 시청 시간이 낮아 추천 우선순위가 떨어집니다. 셋째, ${minMin}분 ${minSec}초 이상의 영상은 광고 삽입 빈도가 높아 수익화에도 유리하고, 시청자가 충분한 정보를 얻을 수 있어 재생목록 추가나 구독 전환율이 높습니다. 따라서 영상을 조금 더 길게 편집하거나, 추가적인 유용한 정보를 포함하여 시청자에게 더 큰 가치를 제공하는 것이 좋습니다.`;
                    } else if (isTooLong) {
                        reasonText = `현재 영상 길이(${currentLengthStr})가 이 카테고리의 추천 길이보다 깁니다. 긴 영상은 여러 가지 이유로 추천하지 않습니다: 첫째, 시청자들의 집중력을 유지하기 어려워 중간에 이탈하는 비율이 높아집니다. 둘째, 시청 완료율(Completion Rate)이 낮아지면 YouTube 알고리즘이 해당 영상을 덜 추천하게 됩니다. 셋째, ${minMin}분 ${minSec}초 ~ ${maxMin}분 ${maxSec}초 사이의 영상은 시청자들이 처음부터 끝까지 시청하기 좋은 적절한 길이로, 이 범위의 영상들은 높은 시청 완료율을 보이며 알고리즘 추천에 유리합니다. 따라서 핵심 내용에 집중하고 불필요한 부분을 편집하여 권장 길이 범위 내로 조정하거나, 긴 콘텐츠를 여러 개의 짧은 에피소드로 나누는 것을 권장합니다.`;
                    }
                    detailedRecommendations.push({
                        type: 'length',
                        current: currentLengthStr,
                        recommended: `${minMin}분 ${minSec}초 ~ ${maxMin}분 ${maxSec}초`,
                        description: `영상 길이를 ${minMin}분 ${minSec}초 ~ ${maxMin}분 ${maxSec}초 사이로 조정하시는 것을 권장합니다. ${reasonText}`
                    });
                }
            }

            // 5. 캡션 상태 검사
            if (recommendations.caption_available !== undefined && (data.captionStatus || data.hasSubtitles !== undefined)) {
                const captionStatus = data.captionStatus || (data.hasSubtitles ? '있음' : '없음');
                const recCaption = recommendations.caption_available;
                
                if (recCaption === -1) {
                    strengths.push('캡션 상태는 선택에 따라 달라질 수 있습니다.');
                } else if (recCaption === 1 && (captionStatus === '있음' || captionStatus === 'yes' || data.hasSubtitles)) {
                    strengths.push('캡션이 활성화되어 있어 접근성이 향상됩니다.');
                } else if (recCaption === 0 && (captionStatus === '없음' || captionStatus === 'no' || !data.hasSubtitles)) {
                    strengths.push('이 카테고리에서는 캡션 없음이 일반적입니다.');
                } else {
                    const captionText = recCaption === 1 ? '캡션 있음' : recCaption === 0 ? '캡션 없음' : '캡션 유무 선택 가능';
                    let reasonText = '';
                    if (recCaption === 1) {
                        reasonText = '캡션이 있으면 청각 장애인이나 소리를 들을 수 없는 환경의 시청자들도 영상을 즐길 수 있어 접근성이 크게 향상됩니다. 또한 캡션은 검색 엔진 최적화(SEO)에 도움이 되어 영상이 더 많이 검색될 수 있고, 시청자들이 내용을 더 잘 이해할 수 있어 시청 시간이 늘어날 수 있습니다.';
                    } else if (recCaption === 0) {
                        reasonText = '이 카테고리에서는 캡션 없음이 일반적이며, 인기 영상들도 대부분 캡션이 없는 형태입니다. 시청자들이 음악이나 자연 소리 등 오디오 요소에 더 집중할 수 있어 영상의 몰입감이 높아질 수 있습니다.';
                    }
                    detailedRecommendations.push({
                        type: 'caption',
                        current: captionStatus,
                        recommended: captionText,
                        description: `이 카테고리에서는 ${captionText}을 권장합니다. ${reasonText}`
                    });
                }
            }

            // 6. 화질 검사
            if (recommendations.definition !== undefined && (data.videoQuality || data.quality)) {
                const quality = data.videoQuality || data.quality || 'HD';
                const recQuality = recommendations.definition === 1 ? 'HD' : 'SD';
                
                if (quality === recQuality || (quality === 'HD' && recommendations.definition === 1)) {
                    strengths.push(`${recQuality} 화질로 적절합니다.`);
                } else {
                    const improvementText = `화질을 ${recQuality}로 조정하시는 것을 권장합니다. ${recQuality} 화질은 이 카테고리의 인기 영상들이 주로 사용하는 화질이며, 시청자들이 선호하는 화질입니다. 높은 화질은 시청 경험을 개선하여 시청자들이 영상을 끝까지 시청할 가능성을 높이고, YouTube 알고리즘도 고화질 영상을 더 많이 추천하는 경향이 있습니다. 또한 전문적인 콘텐츠로 인식되어 채널의 신뢰도 향상에도 도움이 됩니다.`;
                    detailedRecommendations.push({
                        type: 'quality',
                        current: quality,
                        recommended: recQuality,
                        description: improvementText
                    });
                }
            }

            return {
                strengths,
                improvements,
                detailedRecommendations
            };
        }

        // 전역 변수로 strengths와 improvements를 저장 (저장 시 사용)
        let globalStrengths = [];
        let globalImprovements = [];
        
        function generateRecommendations(data, predictionResult) {
            // 영상 길이를 변환된 값으로 사용
            const videoLengthForCheck = parseLengthInput(data.length);
            // 카테고리별 기준 기반 피드백
            const categoryFeedback = generateCategoryBasedFeedback(data);
            
            const strengths = [...categoryFeedback.strengths];
            // improvements는 더 이상 사용하지 않음 (상세 피드백으로 대체)
            
            // 전역 변수에 저장 (저장 시 사용)
            globalStrengths = strengths;
            // globalImprovements는 더 이상 사용하지 않음
            
            // Generate strengths based on prediction results
            if (predictionResult) {
                if (predictionResult.popularity_probability > 0.7) {
                    strengths.push('높은 인기도 확률로 성공적인 영상이 될 가능성이 큽니다.');
                }
            }
            
            // Generate strengths based on input data (기존 로직)
            if (videoLengthForCheck >= 5 && videoLengthForCheck <= 15) {
                if (!categoryFeedback.strengths.some(s => s.includes('영상 길이'))) {
                strengths.push('적절한 영상 길이로 시청자 이탈률이 낮을 것으로 예상됩니다.');
                }
            }
            
            if (['24', '23', '10'].includes(data.category)) {
                strengths.push('인기 카테고리로 높은 조회수 가능성이 있습니다.');
            }
            
            if (data.targetAudience === 'young_adults' || data.targetAudience === 'teens') {
                strengths.push('활발한 시청자층을 타겟으로 하고 있습니다.');
            }
            
            // Generate improvements based on prediction results - 상세 피드백에 추가
            if (predictionResult) {
                if (predictionResult.popularity_probability < 0.3) {
                    const improvementText = '인기도 확률이 낮아 제목이나 썸네일 개선이 필요합니다. 제목은 시청자의 호기심을 자극하고 검색 키워드를 포함해야 하며, 썸네일은 눈에 띄는 이미지와 명확한 텍스트로 클릭률을 높일 수 있습니다. 강력한 제목과 썸네일은 첫 인상에서 차이를 만들고, 클릭률을 높여 알고리즘 추천에 유리하게 작용합니다.';
                    categoryFeedback.detailedRecommendations.push({
                        type: 'title_thumbnail',
                        current: '개선 필요',
                        recommended: '최적화된 제목과 썸네일',
                        description: improvementText
                    });
                }
                
                if (predictionResult.predicted_views < 100000) {
                    const improvementText = '예상 조회수가 낮아 콘텐츠 전략을 재검토해보세요. 트렌드에 맞는 주제 선택, 시청자들이 원하는 내용 구성, 적절한 카테고리 선택 등을 고려해보시기 바랍니다. 또한 키워드 연구를 통해 검색량이 높은 주제를 다루거나, 시청자들의 댓글과 피드백을 반영하여 콘텐츠를 개선하면 조회수 향상에 도움이 됩니다.';
                    categoryFeedback.detailedRecommendations.push({
                        type: 'content_strategy',
                        current: '개선 필요',
                        recommended: '최적화된 콘텐츠 전략',
                        description: improvementText
                    });
                }
            }
            
            // Generate improvements based on input data (기존 로직) - 상세 피드백에 추가
            // 카테고리별 권장사항이 없는 경우에만 일반적인 영상 길이 체크 적용
            const hasCategoryLengthRecommendation = categoryFeedback.detailedRecommendations.some(r => r.type === 'length');
            const categoryHasDurationRecommendation = categoryRecommendations[data.category] && categoryRecommendations[data.category].duration_sec;
            
            // 카테고리별 영상 길이 권장사항이 없을 때만 일반 체크 적용
            if (!categoryHasDurationRecommendation) {
                const convertedLength = parseLengthInput(data.length);
                if (convertedLength > 20) {
                    if (!hasCategoryLengthRecommendation) {
                        const improvementText = '영상 길이가 길어 시청자 이탈률이 높을 수 있습니다. 20분 이상의 긴 영상은 시청자들의 집중력 유지가 어려워 중간에 이탈하는 경우가 많습니다. 영상을 여러 개의 짧은 에피소드로 나누거나, 핵심 내용에 집중하여 불필요한 부분을 편집하는 것이 좋습니다. 시청 완료율이 높아지면 YouTube 알고리즘이 영상을 더 많이 추천하게 됩니다.';
                        categoryFeedback.detailedRecommendations.push({
                            type: 'length',
                            current: formatLengthDisplay(data.length),
                            recommended: '20분 이하',
                            description: improvementText
                        });
                    }
                }
                
                if (convertedLength < 3) {
                    if (!hasCategoryLengthRecommendation) {
                        const improvementText = '영상이 너무 짧아 충분한 내용 전달이 어려울 수 있습니다. 3분 미만의 짧은 영상은 시청자들에게 충분한 가치를 제공하기 어려우며, 시청 시간이 짧아 광고 수익이나 알고리즘 추천에도 불리합니다. 핵심 내용을 유지하면서도 시청자들이 만족할 만한 적절한 길이로 확장하는 것을 권장합니다.';
                        categoryFeedback.detailedRecommendations.push({
                            type: 'length',
                            current: formatLengthDisplay(data.length),
                            recommended: '3분 이상',
                            description: improvementText
                        });
                    }
                }
            }
            
            if (!data.description || data.description.length < 50) {
                const improvementText = '영상 설명을 더 자세히 작성하면 검색 노출이 개선됩니다. 상세한 설명은 YouTube 검색 알고리즘이 영상의 내용을 더 잘 이해하도록 도와주어 관련 검색어로 영상이 노출될 가능성이 높아집니다. 또한 시청자들이 영상의 내용을 미리 파악할 수 있어 클릭률과 시청 완료율 향상에도 도움이 됩니다. 키워드를 자연스럽게 포함하고, 영상의 주요 내용과 타임스탬프를 포함하면 더욱 효과적입니다.';
                categoryFeedback.detailedRecommendations.push({
                    type: 'description',
                    current: data.description ? `${data.description.length}자` : '없음',
                    recommended: '50자 이상',
                    description: improvementText
                });
            }
            
            // 카테고리별 상세 피드백을 형식에 맞게 변환
            const formattedDetailedRecommendations = categoryFeedback.detailedRecommendations.map(rec => {
                const typeNames = {
                    'time': '업로드 시간',
                    'day': '업로드 요일',
                    'date': '업로드 날짜',
                    'length': '영상 길이',
                    'caption': '캡션 상태',
                    'quality': '화질',
                    'title_thumbnail': '제목 및 썸네일',
                    'content_strategy': '콘텐츠 전략',
                    'description': '영상 설명'
                };
                
                // undefined 체크 및 기본값 설정
                const current = rec.current || '미입력';
                const recommended = rec.recommended || '확인 불가';
                const description = rec.description || '';
                const type = typeNames[rec.type] || rec.type || '항목';
                
                return {
                    title: type,
                    current: current,
                    recommended: recommended,
                    description: description,
                    type: rec.type
                };
            });
            
            // Display recommendations (중복 제거를 위해 formattedDetailedRecommendations 사용)
            displayRecommendations(strengths, [], formattedDetailedRecommendations);
            
            // 피드백 적용시 예상 조회수 계산
            // 카테고리별 권장사항만 체크하기 위해 원본 categoryFeedback 생성
            const originalCategoryFeedback = generateCategoryBasedFeedback(data);
            console.log('🔍 originalCategoryFeedback 생성:', originalCategoryFeedback);
            console.log('   - strengths:', originalCategoryFeedback.strengths);
            console.log('   - detailedRecommendations:', originalCategoryFeedback.detailedRecommendations);
            
            // 예측 결과가 있으면 즉시 체크
            if (predictionResult && predictionResult.predicted_views > 0) {
                calculateRecommendedPrediction(data, originalCategoryFeedback, predictionResult);
            } else {
                // 예측 결과가 아직 없어도 카테고리별 권장사항만 체크해서 "완벽합니다" 표시 가능
                const categoryOnlyRecommendations = originalCategoryFeedback.detailedRecommendations 
                    ? originalCategoryFeedback.detailedRecommendations.filter(rec => 
                        ['time', 'day', 'date', 'length', 'caption', 'quality'].includes(rec.type)
                    )
                    : [];
                
                // 카테고리별 권장사항이 없고 strengths가 있으면 즉시 "완벽합니다" 표시
                if ((!categoryOnlyRecommendations || categoryOnlyRecommendations.length === 0) && 
                    originalCategoryFeedback.strengths && originalCategoryFeedback.strengths.length > 0) {
                    // 예측 결과가 없어도 "완벽합니다" 표시 (임시 예측 결과 객체 생성)
                    const tempPredictionResult = {
                        predicted_views: 0, // 나중에 실제 값으로 업데이트됨
                        pred_popular_prob: 0
                    };
                    calculateRecommendedPrediction(data, originalCategoryFeedback, tempPredictionResult);
                    
                    // 예측 결과가 준비되면 다시 체크
                    const checkInterval = setInterval(() => {
                        const savedPredictionResult = JSON.parse(sessionStorage.getItem('predictionResult') || '{}');
                        if (savedPredictionResult && savedPredictionResult.predicted_views > 0) {
                            clearInterval(checkInterval);
                            calculateRecommendedPrediction(data, originalCategoryFeedback, savedPredictionResult);
                        }
                    }, 500); // 0.5초마다 체크
                    
                    // 10초 후에도 예측 결과가 없으면 타임아웃
                    setTimeout(() => {
                        clearInterval(checkInterval);
                    }, 10000);
                }
            }
        }
        
        // 권장사항 문자열에서 시간값 파싱 (예: "17시 30분 ~ 18시" → 17.5)
        function parseTimeFromRecommended(recommendedStr) {
            // "17시 30분 ~ 18시" 형식에서 최소값과 최대값 추출
            const parts = recommendedStr.split('~');
            if (parts.length === 2) {
                const minStr = parts[0].trim();
                const maxStr = parts[1].trim();
                
                const parseTimeStr = (timeStr) => {
                    const hourMatch = timeStr.match(/(\d+)시/);
                    const minuteMatch = timeStr.match(/(\d+)분/);
                    const hour = hourMatch ? parseInt(hourMatch[1]) : 0;
                    const minute = minuteMatch ? parseInt(minuteMatch[1]) : 0;
                    return hour + minute / 60;
                };
                
                const minTime = parseTimeStr(minStr);
                const maxTime = parseTimeStr(maxStr);
                return (minTime + maxTime) / 2; // 중간값 반환
            }
            return null;
        }
        
        // 권장사항 문자열에서 날짜 범위 파싱 (예: "10일 ~ 26일" → 18)
        function parseDateRangeFromRecommended(recommendedStr) {
            const match = recommendedStr.match(/(\d+)일\s*~\s*(\d+)일/);
            if (match) {
                const min = parseInt(match[1]);
                const max = parseInt(match[2]);
                return Math.floor((min + max) / 2); // 중간값 반환
            }
            return null;
        }
        
        // 권장사항 문자열에서 영상 길이 파싱 (예: "3분 55초 ~ 5분 47초" → 초 단위 중간값)
        function parseLengthFromRecommended(recommendedStr) {
            const match = recommendedStr.match(/(\d+)분\s*(\d+)초\s*~\s*(\d+)분\s*(\d+)초/);
            if (match) {
                const minMin = parseInt(match[1]);
                const minSec = parseInt(match[2]);
                const maxMin = parseInt(match[3]);
                const maxSec = parseInt(match[4]);
                const minSeconds = minMin * 60 + minSec;
                const maxSeconds = maxMin * 60 + maxSec;
                return Math.floor((minSeconds + maxSeconds) / 2);
            }
            // "3분 ~ 5분" 형식도 처리
            const match2 = recommendedStr.match(/(\d+)분\s*~\s*(\d+)분/);
            if (match2) {
                const minMin = parseInt(match2[1]);
                const maxMin = parseInt(match2[2]);
                return Math.floor((minMin + maxMin) / 2) * 60; // 분을 초로 변환
            }
            return null;
        }
        
        // 요일 문자열 파싱 (예: "월, 화, 수요일" → ['월', '화', '수'])
        function parseDaysFromRecommended(recommendedStr) {
            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
            const days = [];
            dayNames.forEach(day => {
                if (recommendedStr.includes(day)) {
                    days.push(day);
                }
            });
            return days.length > 0 ? days : null;
        }
        
        // 카테고리별 추천 기준을 적용한 데이터 생성 (10% 또는 90% 위치 값 사용)
        function createOptimizedData(originalData, categoryFeedback, percentLocation = 0.9) {
            const optimizedData = { ...originalData };
            const currentDate = originalData.uploadTime ? new Date(originalData.uploadTime) : new Date();
            
            const category = originalData.category;
            const recommendations = categoryRecommendations[category];
            
            if (!recommendations) {
                return null;
            }
            
            // 모든 범위 값들을 지정된 위치 값으로 계산하여 적용
            // 위치 값 계산 함수 (percentLocation: 0.1 = 10%, 0.9 = 90%)
            const getPercentValue = (min, max) => {
                return min + (max - min) * percentLocation;
            };
            
            // 1. 업로드 시간: pub_hour의 지정된 위치 값
            if (recommendations.pub_hour && originalData.uploadTime) {
                const optimalTime = getPercentValue(recommendations.pub_hour.min, recommendations.pub_hour.max);
                const optimalHour = Math.floor(optimalTime);
                const optimalMinutes = Math.round((optimalTime % 1) * 60);
                
                // 월: pub_month의 지정된 위치 값
                const optimalMonth = recommendations.pub_month 
                    ? Math.floor(getPercentValue(recommendations.pub_month.min, recommendations.pub_month.max))
                    : currentDate.getMonth() + 1;
                
                // 일: pub_day의 지정된 위치 값
                const optimalDay = Math.floor(getPercentValue(recommendations.pub_day.min, recommendations.pub_day.max));
                
                // 요일: 첫 번째 권장 요일
                const optimalWeekdayIndex = recommendations.pub_weekday && recommendations.pub_weekday.length > 0 
                    ? recommendations.pub_weekday[0] 
                    : currentDate.getDay();
                
                const optimizedDate = new Date(currentDate.getFullYear(), optimalMonth - 1, optimalDay, optimalHour, optimalMinutes);
                const currentDayOfWeek = optimizedDate.getDay();
                const dayDiff = optimalWeekdayIndex - currentDayOfWeek;
                optimizedDate.setDate(optimizedDate.getDate() + dayDiff);
                
                optimizedData.uploadTime = optimizedDate.toISOString();
            }
            
            // 2. 영상 길이: duration_sec의 지정된 위치 값
            if (recommendations.duration_sec) {
                const optimalLengthSeconds = Math.floor(getPercentValue(recommendations.duration_sec.min, recommendations.duration_sec.max));
                optimizedData.length = Math.round(optimalLengthSeconds / 60); // 초를 분으로 변환
            }
            
            // 3. 캡션 상태: caption_available 값 사용 (예상 조회수 계산과 동일한 형식으로 변환)
            if (recommendations.caption_available !== undefined) {
                if (recommendations.caption_available === 1) {
                    optimizedData.captionStatus = '있음';
                    optimizedData.hasSubtitles = 'provided'; // 예상 조회수 계산과 동일한 형식
                } else if (recommendations.caption_available === 0) {
                    optimizedData.captionStatus = '없음';
                    optimizedData.hasSubtitles = 'not_provided'; // 예상 조회수 계산과 동일한 형식
                }
                // caption_available === -1 인 경우 원본 값 유지
            }
            
            // 4. 화질: definition 값 사용
            if (recommendations.definition !== undefined) {
                optimizedData.quality = recommendations.definition === 1 ? 'HD' : 'SD';
                optimizedData.videoQuality = recommendations.definition === 1 ? 'HD' : 'SD';
            }
            
            // 5. 구독자 수: 실제 사용자 입력 값 사용 (원본 값 유지)
            // 권장사항 적용 시에도 사용자의 실제 구독자 수를 사용하여 개별 차이를 반영
            optimizedData.subscriberCount = originalData.subscriberCount || 0;
            
            return optimizedData;
        }
        
        // 피드백 적용시 예상 조회수 계산 (90% 위치 값만)
        async function calculateRecommendedPrediction(data, categoryFeedback, currentPredictionResult) {
            try {
                console.log('🔍 피드백 적용시 예상 조회수 계산 시작');
                
                // 카테고리별 권장사항만 체크 (예측 결과나 설명 길이 등은 제외)
                const categoryOnlyRecommendations = categoryFeedback.detailedRecommendations 
                    ? categoryFeedback.detailedRecommendations.filter(rec => 
                        ['time', 'day', 'date', 'length', 'caption', 'quality'].includes(rec.type)
                    )
                    : [];
                
                console.log('🔍 카테고리별 권장사항 체크:');
                console.log('   - 전체 detailedRecommendations:', categoryFeedback.detailedRecommendations);
                console.log('   - 카테고리별 권장사항만 필터링:', categoryOnlyRecommendations);
                console.log('   - 카테고리별 권장사항 개수:', categoryOnlyRecommendations ? categoryOnlyRecommendations.length : 0);
                
                // 카테고리별 권장사항이 없는 경우 (모든 카테고리 항목이 최적 범위에 있는 경우)
                // 또는 카테고리별 권장 기준 데이터가 없는 경우도 "완벽합니다" 표시
                if ((!categoryOnlyRecommendations || categoryOnlyRecommendations.length === 0) && 
                    categoryFeedback.strengths && categoryFeedback.strengths.length > 0) {
                    console.log('✅ 모든 카테고리 항목이 최적 범위에 있어 추가 권장사항이 없습니다.');
                    
                    // UI에 긍정적인 메시지 표시
                    const recommendedSection = document.getElementById('recommendedPredictionSection');
                    const recommendedViewsElement = document.getElementById('recommendedViews');
                    const improvementPercent = document.getElementById('improvementPercent');
                    const improvementAmount = document.getElementById('improvementAmount');
                    
                    if (recommendedSection && recommendedViewsElement) {
                        recommendedSection.style.display = 'block';
                        
                        // 카드 스타일을 초록색 계열로 변경 (최적화 상태)
                        const feedbackCard = recommendedSection.querySelector('.feedback-card');
                        if (feedbackCard) {
                            feedbackCard.style.border = '2px solid rgba(40, 167, 69, 0.5)';
                            feedbackCard.style.background = 'linear-gradient(135deg, rgba(40, 167, 69, 0.05) 0%, rgba(40, 167, 69, 0.1) 100%)';
                        }
                        
                        // 현재 예상 조회수 표시 (가중치 적용하지 않은 원본 값)
                        // 예측 결과가 아직 없으면 "계산 중..." 표시
                        const originalViews = currentPredictionResult.predicted_views || 0;
                        if (originalViews > 0) {
                            recommendedViewsElement.textContent = Math.floor(originalViews).toLocaleString();
                        } else {
                            recommendedViewsElement.textContent = '계산 중...';
                        }
                        recommendedViewsElement.style.color = '#28a745';
                        
                        // 숫자와 통계 부분 표시
                        const colMd6First = recommendedSection.querySelector('.col-md-6:first-child');
                        if (colMd6First) {
                            colMd6First.style.display = 'block';
                        }
                        
                        // 개선율 표시 (0%로 표시)
                        const improvementStats = recommendedSection.querySelector('#improvementStats');
                        if (improvementStats) {
                            improvementStats.style.display = 'block';
                        }
                        if (improvementPercent) {
                            improvementPercent.textContent = '0.0%';
                            improvementPercent.style.color = '#28a745';
                        }
                        if (improvementAmount) {
                            improvementAmount.textContent = '0회';
                            improvementAmount.style.color = '#28a745';
                        }
                        
                        // 제목 변경 (다른 섹션과 일관성 있게)
                        const sectionTitle = recommendedSection.querySelector('h4');
                        if (sectionTitle) {
                            sectionTitle.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i>이미 최적화된 설정입니다!';
                            sectionTitle.style.color = '#28a745';
                            sectionTitle.style.textAlign = 'center';
                            sectionTitle.style.width = '100%';
                            sectionTitle.style.fontSize = '1.75rem';
                            sectionTitle.style.fontWeight = '700';
                            sectionTitle.style.marginBottom = '20px';
                        }
                        
                        // 설명 부분을 좌우로 나누기
                        const rowElement = recommendedSection.querySelector('.row.align-items-center');
                        if (rowElement) {
                            rowElement.innerHTML = `
                                <div class="col-md-6">
                                    <div class="text-center p-4" style="height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center;">
                                        <i class="bi bi-check-circle-fill" style="font-size: 4rem; color: #28a745;"></i>
                                        <h5 class="mt-3 mb-0" style="color: #28a745; font-size: 1.5rem; font-weight: 700;">
                                            완벽합니다! 🎉
                                        </h5>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="p-4" style="height: 100%; display: flex; flex-direction: column; justify-content: center;">
                                        <p style="color: #ffffff; line-height: 1.8; font-size: 1.05rem; margin: 0;">
                                            입력하신 모든 설정이 이 카테고리의 최적 범위에 있습니다.<br><br>
                                            영상 길이, 자막 제공 여부, 해상도 품질, 업로드 예정 시간 등이 모두 최적화되어 있어,<br><br>
                                            <strong style="color: #28a745;">현재 설정 그대로 업로드하시면 좋은 결과를 기대할 수 있습니다!</strong>
                                        </p>
                                    </div>
                                </div>
                            `;
                        }
                    }
                    return;
                }
                
                // 최적화된 데이터 생성 (90% 위치 값)
                const optimizedData = createOptimizedData(data, categoryFeedback, 0.9);
                console.log('📊 최적화된 데이터:', optimizedData);
                console.log('📊 원본 데이터:', data);
                console.log('📊 카테고리 피드백:', categoryFeedback);
                
                if (!optimizedData) {
                    console.log('⚠️ 카테고리별 추천 기준이 없어 권장사항 조회수 계산을 건너뜁니다.');
                    
                    // 사용자에게 안내 메시지 표시
                    const recommendedSection = document.getElementById('recommendedPredictionSection');
                    const recommendedViewsElement = document.getElementById('recommendedViews');
                    const improvementPercent = document.getElementById('improvementPercent');
                    const improvementAmount = document.getElementById('improvementAmount');
                    
                    if (recommendedSection && recommendedViewsElement) {
                        recommendedSection.style.display = 'block';
                        
                        // 카드 스타일을 정보성으로 변경
                        const feedbackCard = recommendedSection.querySelector('.feedback-card');
                        if (feedbackCard) {
                            feedbackCard.style.border = '2px solid rgba(108, 117, 125, 0.5)';
                            feedbackCard.style.background = 'linear-gradient(135deg, rgba(108, 117, 125, 0.05) 0%, rgba(108, 117, 125, 0.1) 100%)';
                        }
                        
                        // 현재 예상 조회수 표시
                        const currentViews = currentPredictionResult.predicted_views || 0;
                        recommendedViewsElement.textContent = Math.floor(currentViews).toLocaleString();
                        recommendedViewsElement.style.color = '#6c757d';
                        
                        // 제목 변경
                        const sectionTitle = recommendedSection.querySelector('h4');
                        if (sectionTitle) {
                            sectionTitle.innerHTML = '<i class="bi bi-info-circle-fill me-2"></i>권장사항 계산 불가';
                            sectionTitle.style.color = '#6c757d';
                        }
                        
                        // 개선율 표시 숨기기
                        if (improvementPercent) {
                            improvementPercent.textContent = '-';
                            improvementPercent.style.color = '#6c757d';
                        }
                        if (improvementAmount) {
                            improvementAmount.textContent = '-';
                            improvementAmount.style.color = '#6c757d';
                        }
                        
                        // 설명 추가
                        const descriptionArea = recommendedSection.querySelector('.col-md-6:last-child');
                        if (descriptionArea) {
                            descriptionArea.innerHTML = `
                                <div class="text-center p-4">
                                    <i class="bi bi-info-circle-fill" style="font-size: 3rem; color: #6c757d;"></i>
                                    <h5 class="mt-3 mb-3" style="color: #6c757d; font-weight: 700;">카테고리별 기준 정보 없음</h5>
                                    <p style="color: #ffffff; line-height: 1.8; font-size: 1rem;">
                                        이 카테고리에 대한 추천 기준 데이터가 아직 준비되지 않았습니다.<br>
                                        현재 예상 조회수는 표시되지만, 피드백 적용시 예상 조회수는 계산할 수 없습니다.<br>
                                        <strong style="color: #6c757d;">일반적인 권장사항을 참고하여 영상을 최적화해보세요.</strong>
                                    </p>
                                </div>
                            `;
                        }
                    }
                    return;
                }
                
                // UI 표시
                const recommendedSection = document.getElementById('recommendedPredictionSection');
                const recommendedViewsElement = document.getElementById('recommendedViews');
                if (!recommendedSection || !recommendedViewsElement) {
                    console.error('❌ 권장사항 섹션 요소를 찾을 수 없습니다.');
                    return;
                }
                
                recommendedSection.style.display = 'block';
                recommendedViewsElement.textContent = '계산 중...';
                
                // API 호출하여 예측 조회수 계산
                const sessionToken = localStorage.getItem('session_token');
                let url = `${API_BASE}/api/videos/create`;
                if (sessionToken) {
                    url += `?session_token=${sessionToken}`;
                }
                
                const requestBody = {
                    title: optimizedData.title,
                    category: optimizedData.category,
                    length: typeof optimizedData.length === 'number' ? optimizedData.length : parseLengthInput(String(optimizedData.length)),
                    upload_time: optimizedData.uploadTime,
                    description: optimizedData.description || data.description || '',
                    thumbnail_image: optimizedData.thumbnailImage || data.thumbnailImage || '',
                    has_subtitles: optimizedData.hasSubtitles !== undefined ? optimizedData.hasSubtitles : (data.hasSubtitles || 'not_provided'),
                    video_quality: optimizedData.videoQuality || data.videoQuality || 'HD',
                    subscriber_count: optimizedData.subscriberCount || data.subscriberCount || 0
                };
                
                console.log('📤 API 요청:', url, requestBody);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('📥 API 응답 상태:', response.status, response.statusText);
                
                if (response.ok) {
                    const saveData = await response.json();
                    console.log('📥 API 응답 데이터:', saveData);
                    
                    if (saveData.success && saveData.data && saveData.data.prediction) {
                        const recommendedViewsRaw = saveData.data.prediction.predicted_views;
                        console.log('📊 원본 예상 조회수:', recommendedViewsRaw);
                        
                        // 현재 조회수 계산을 위한 변수 선언
                        const videoData = JSON.parse(sessionStorage.getItem('videoData') || '{}');
                        const categoryRankInfo = getCategoryRankStatus(data.category);
                        const isTrendCategory = categoryRankInfo.inTop5;
                        const subscriberCount = (videoData && videoData.subscriberCount) ? videoData.subscriberCount : (data.subscriberCount || 0);
                        
                        // 피드백 적용시 예상 조회수에도 가중치 적용 (현재 예상 조회수와 동일하게)
                        const recommendedViews = adjustPredictedViews(recommendedViewsRaw, subscriberCount, isTrendCategory);
                        console.log('📊 피드백 적용시 예상 조회수 (가중치 적용):', recommendedViews, '(원본:', recommendedViewsRaw, ')');
                        
                        // 현재 조회수 계산: localStorage의 원본 값에 가중치를 적용한 값을 사용 (더 정확함)
                        const savedPredictionResult = JSON.parse(sessionStorage.getItem('predictionResult') || '{}');
                        const originalViews = savedPredictionResult.predicted_views || currentPredictionResult.predicted_views;
                        
                        let currentViews = null;
                        if (originalViews && originalViews > 0) {
                            currentViews = adjustPredictedViews(originalViews, subscriberCount, isTrendCategory);
                            console.log('📊 localStorage에서 계산한 현재 조회수:', currentViews, '(원본:', originalViews, ')');
                        } else {
                            // 최후의 수단: currentPredictionResult 사용
                            currentViews = adjustPredictedViews(currentPredictionResult.predicted_views, subscriberCount, isTrendCategory);
                            console.log('📊 currentPredictionResult에서 계산한 현재 조회수:', currentViews);
                        }
                        
                        // 화면에 표시된 값을 직접 사용 (가장 정확함)
                        const currentViewsElement = document.getElementById('predictedViews');
                        let currentViewsForCalculation = currentViews;
                        
                        if (currentViewsElement) {
                            const displayedText = currentViewsElement.textContent.trim();
                            const displayedNumber = parseInt(displayedText.replace(/,/g, '').replace(/[^0-9]/g, ''));
                            if (!isNaN(displayedNumber) && displayedNumber > 0) {
                                currentViewsForCalculation = displayedNumber;
                                console.log('✅ 화면에 표시된 값을 사용합니다:', currentViewsForCalculation);
                                
                                // 계산 값과 비교하여 검증 (디버깅용)
                                const diff = Math.abs(displayedNumber - currentViews);
                                const diffPercent = (diff / currentViews) * 100;
                                if (diffPercent > 5) { // 5% 이상 차이나면 경고
                                    console.warn('⚠️ 화면 값과 계산 값이 다릅니다. 화면:', displayedNumber, '계산:', currentViews, '차이:', diffPercent.toFixed(1) + '%');
                                    console.warn('⚠️ 화면 값을 우선 사용합니다.');
                                }
                            } else {
                                console.log('📊 계산된 값을 사용합니다:', currentViews);
                            }
                        }
                        
                        console.log('📊 현재 조회수 (계산용):', currentViewsForCalculation);
                        
                        // 결과 표시
                        animateNumber('recommendedViews', recommendedViews, '');
                        
                        // 증가율 계산 (화면에 표시된 현재 조회수와 비교)
                        if (currentViewsForCalculation > 0) {
                            const improvement = ((recommendedViews - currentViewsForCalculation) / currentViewsForCalculation) * 100;
                            const improvementAmount = recommendedViews - currentViewsForCalculation;
                            
                            // 비정상적인 계산 결과 검증
                            if (Math.abs(improvement) > 1000) {
                                console.error('❌ 비정상적인 증가율 감지:', improvement.toFixed(1) + '%');
                                console.error('   현재 조회수:', currentViews);
                                console.error('   피드백 적용시 예상 조회수:', recommendedViews);
                                console.error('   원본 예상 조회수:', originalViews);
                                console.error('   피드백 원본 예상 조회수:', recommendedViewsRaw);
                            }
                            
                            document.getElementById('improvementPercent').textContent = 
                                improvement > 0 ? `+${improvement.toFixed(1)}%` : `${improvement.toFixed(1)}%`;
                            document.getElementById('improvementAmount').textContent = 
                                `${improvementAmount > 0 ? '+' : ''}${Math.floor(improvementAmount).toLocaleString()}회`;
                            
                            console.log('📊 증가율:', improvement.toFixed(1) + '%', '증가량:', Math.floor(improvementAmount).toLocaleString() + '회');
                            console.log('📊 비교 값 - 현재:', currentViewsForCalculation, '권장:', recommendedViews);
                        } else {
                            console.error('❌ 현재 조회수가 0이거나 유효하지 않습니다:', currentViewsForCalculation);
                            document.getElementById('improvementPercent').textContent = '-';
                            document.getElementById('improvementAmount').textContent = '-';
                        }
                        
                        console.log('✅ 피드백 적용시 예상 조회수 계산 완료');
                    } else {
                        console.error('❌ API 응답에 예측 데이터가 없습니다:', saveData);
                        recommendedViewsElement.textContent = '계산 실패 (데이터 없음)';
                    }
                } else {
                    const errorText = await response.text().catch(() => '알 수 없는 오류');
                    console.error('❌ API 호출 실패:', response.status, errorText);
                    console.error('❌ 요청 데이터:', requestBody);
                    recommendedViewsElement.textContent = `계산 실패 (${response.status})`;
                    
                    // 에러 상세 정보 표시
                    const errorInfo = document.createElement('div');
                    errorInfo.style.color = '#ff6b6b';
                    errorInfo.style.fontSize = '0.9rem';
                    errorInfo.style.marginTop = '10px';
                    errorInfo.textContent = `서버 응답: ${response.status} ${response.statusText}`;
                    recommendedViewsElement.parentElement.appendChild(errorInfo);
                }
            } catch (error) {
                console.error('❌ 권장사항 적용 조회수 계산 실패:', error);
                console.error('❌ 에러 스택:', error.stack);
                console.error('❌ 최적화된 데이터:', optimizedData);
                const recommendedViewsElement = document.getElementById('recommendedViews');
                if (recommendedViewsElement) {
                    recommendedViewsElement.textContent = `계산 실패: ${error.message}`;
                }
            }
        }
        
        function displayRecommendations(strengths, improvements, detailed) {
            const strengthsList = document.getElementById('strengths');
            const detailedDiv = document.getElementById('detailedRecommendations');
            
            if (strengthsList) {
                strengthsList.innerHTML = strengths.length > 0 
                    ? strengths.map((strength, index) => `
                        <li class="mb-3 p-3" style="background: rgba(40, 167, 69, 0.1); border-radius: 10px; border-left: 3px solid #28a745; list-style: none;">
                            <div class="d-flex align-items-start">
                                <i class="bi bi-check-circle-fill text-success me-3 fs-5 mt-1"></i>
                                <span style="line-height: 1.6;">${strength || ''}</span>
                            </div>
                        </li>
                    `).join('')
                    : '<li class="text-muted p-3 text-center" style="list-style: none;">강점 사항이 없습니다.</li>';
            }
            
            
            if (detailedDiv) {
                detailedDiv.innerHTML = detailed.length > 0
                    ? detailed.map(rec => {
                        // undefined 체크
                        const title = rec.title || '추천사항';
                        let content = '';
                        
                        // 구조화된 데이터인 경우 (current, recommended가 있는 경우)
                        if (rec.current !== undefined && rec.recommended !== undefined) {
                            const current = rec.current || '미입력';
                            const recommended = rec.recommended || '확인 불가';
                            const description = rec.description || '';
                            
                            content = `
                                <div class="d-flex align-items-start mb-2">
                                    <div class="flex-grow-1">
                                        <div class="d-flex align-items-center mb-2">
                                            <span class="badge bg-secondary me-2">현재</span>
                                            <span class="fw-semibold">${current}</span>
                                        </div>
                                        <div class="d-flex align-items-center mb-3">
                                            <span class="badge bg-warning me-2">추천</span>
                                            <span class="fw-bold text-warning">${recommended}</span>
                                        </div>
                                        ${description ? `<div class="mt-3 p-3" style="background: rgba(255, 255, 255, 0.05); border-radius: 10px; border-left: 3px solid #ffc107;"><strong style="color: #ffc107; font-size: 1.05rem; display: block; margin-bottom: 8px;">권장 사유 및 상세 설명</strong><div style="color: #ffffff; line-height: 1.8; font-size: 0.95rem;">${description}</div></div>` : ''}
                                    </div>
                                    <div class="ms-3">
                                        <i class="bi bi-arrow-right-circle text-warning fs-4"></i>
                                    </div>
                                </div>
                            `;
                        } else {
                            // 일반 텍스트인 경우
                            const text = rec.text || '';
                            content = `<div class="recommendation-text">${text}</div>`;
                        }
                        
                        return `
                            <div class="recommendation-item mb-3 p-4" style="background: linear-gradient(135deg, rgba(255, 193, 7, 0.08) 0%, rgba(255, 193, 7, 0.12) 100%); border-radius: 15px; border-left: 4px solid #ffc107; transition: all 0.3s ease;">
                                <div class="recommendation-title fw-bold mb-3" style="color: #ffc107; font-size: 1.2rem;">
                                    개선점: ${title}
                                </div>
                                ${content}
                            </div>
                        `;
                    }).join('')
                    : '<p class="text-muted text-center py-4">상세 추천사항이 없습니다.</p>';
            }
        }
        
        
        function generateNewFeedback() {
            window.location.href = 'feedback.html';
        }
        
        
        function copyToClipboard(button, text) {
            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = '복사됨!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 1500);
            }).catch(err => {
                console.error('클립보드 복사 실패:', err);
                alert('클립보드 복사 실패!');
            });
        }

        
        function downloadReport() {
            try {
                // 현재 분석 결과 수집
                const videoData = JSON.parse(sessionStorage.getItem('videoData'));
                const predictionResult = JSON.parse(sessionStorage.getItem('predictionResult'));
                
                if (!videoData) {
                    alert('저장할 영상 정보가 없습니다. 다시 입력해주세요.');
                    return;
                }
                
                // 태그 정보 수집
                const finalTags = [];
                const finalDiv = document.getElementById('finalTags');
                if (finalDiv) {
                    finalDiv.querySelectorAll('.tag-badge').forEach(badge => {
                        const tagText = badge.textContent.trim();
                        const cleanTag = tagText.replace(/^#/, '').replace(/\s*\([^)]*\)$/, '').trim();
                        if (cleanTag && !tagText.includes('(')) {
                            finalTags.push(cleanTag);
                        }
                    });
                }
                
                // 개선점 정보 수집 (detailedRecommendations div에서)
                const improvements = [];
                const detailedRecDiv = document.getElementById('detailedRecommendations');
                if (detailedRecDiv) {
                    const recItems = detailedRecDiv.querySelectorAll('.recommendation-item');
                    recItems.forEach(item => {
                        const titleEl = item.querySelector('.recommendation-title');
                        if (titleEl) {
                            const title = titleEl.textContent.replace(/개선점:\s*/, '').trim();
                            // 내용 추출 (현재/추천 정보와 설명 모두 포함)
                            let content = '';
                            const currentEl = item.querySelector('.badge.bg-secondary')?.nextElementSibling;
                            const recommendedEl = item.querySelector('.badge.bg-warning')?.nextElementSibling;
                            const descEl = item.querySelector('div[style*="background: rgba(255, 255, 255, 0.05)"]');
                            
                            if (currentEl && recommendedEl) {
                                const current = currentEl.textContent.trim();
                                const recommended = recommendedEl.textContent.trim();
                                content = `현재: ${current} → 추천: ${recommended}`;
                                if (descEl) {
                                    const descText = descEl.textContent.trim();
                                    if (descText) {
                                        content += `\n\n${descText}`;
                                    }
                                }
                            } else {
                                // 일반 텍스트인 경우
                                const textEl = item.querySelector('.recommendation-text');
                                if (textEl) {
                                    content = textEl.textContent.trim();
                                } else {
                                    // 전체 텍스트에서 제목 제외한 부분
                                    const allText = item.textContent.trim();
                                    content = allText.replace(title, '').trim();
                                }
                            }
                            
                            if (title && content) {
                                improvements.push({
                                    title: title,
                                    description: content
                                });
                            }
                        }
                    });
                }
                
                // 카테고리 이름 가져오기
                const categoryMap = {
                    '1': 'Film & Animation',
                    '2': 'Autos & Vehicles',
                    '10': 'Music',
                    '15': 'Pets & Animals',
                    '17': 'Sports',
                    '18': 'Short Movies',
                    '19': 'Travel & Events',
                    '20': 'Gaming',
                    '21': 'Videoblogging',
                    '22': 'People & Blogs',
                    '23': 'Comedy',
                    '24': 'Entertainment',
                    '25': 'News & Politics',
                    '26': 'Howto & Style'
                };
                const categoryName = categoryMap[videoData.category] || '기타';
                
                // 보고서 내용 생성
                const reportDate = new Date().toLocaleString('ko-KR');
                const predictedViews = predictionResult?.predicted_views?.toLocaleString() || 'N/A';
                const confidence = predictionResult?.confidence?.toFixed(1) || 'N/A';
                const titleSuggestions = predictionResult?.title_suggestions || [];
                const recommendations = predictionResult?.recommendations || [];
                
                // HTML 형식의 보고서 생성
                let htmlContent = `<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>유튜브 영상 분석 보고서</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', 'Malgun Gothic', '맑은 고딕', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        .header {
            text-align: center;
            border-bottom: 3px solid #ff0000;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #ff0000;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .header .date {
            color: #666;
            font-size: 0.9em;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #ff0000;
        }
        .section h2 {
            color: #ff0000;
            font-size: 1.5em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        .info-grid {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }
        .info-label {
            font-weight: bold;
            color: #555;
        }
        .info-value {
            color: #333;
        }
        .prediction-box {
            background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }
        .prediction-box .big-number {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        .prediction-box .label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .tag-item {
            background: #ff0000;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }
        .title-list, .recommendation-list {
            list-style: none;
            padding-left: 0;
        }
        .title-list li, .recommendation-list li {
            padding: 10px;
            margin: 8px 0;
            background: white;
            border-left: 3px solid #ff0000;
            border-radius: 4px;
        }
        .title-list li {
            font-weight: 500;
        }
        .recommendation-list li {
            line-height: 1.8;
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            color: #666;
            font-size: 0.9em;
        }
        @media print {
            body {
                background: white;
                padding: 0;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 유튜브 영상 분석 보고서</h1>
            <div class="date">생성일: ${reportDate}</div>
        </div>
        
        <div class="section">
            <h2>📹 영상 정보</h2>
            <div class="info-grid">
                <div class="info-label">제목:</div>
                <div class="info-value">${videoData.title || 'N/A'}</div>
                
                <div class="info-label">카테고리:</div>
                <div class="info-value">${categoryName}</div>
                
                <div class="info-label">길이:</div>
                <div class="info-value">${formatLengthDisplay(videoData.length)}</div>
                
                <div class="info-label">업로드 예정:</div>
                <div class="info-value">${videoData.upload_time || '미설정'}</div>`;
                
                if (videoData.description) {
                    htmlContent += `
                <div class="info-label">설명:</div>
                <div class="info-value">${videoData.description}</div>`;
                }
                
                htmlContent += `
            </div>
        </div>
        
        <div class="section">
            <h2>📈 예측 결과</h2>
            <div class="prediction-box">
                <div class="label">예상 조회수</div>
                <div class="big-number">${predictedViews}회</div>
                <div class="label">신뢰도: ${confidence}%</div>`;
                
                if (predictionResult?.model_used) {
                    htmlContent += `
                <div class="label" style="margin-top: 10px;">사용 모델: ${predictionResult.model_used}</div>`;
                }
                
                htmlContent += `
            </div>
        </div>`;
                
                if (titleSuggestions.length > 0) {
                    htmlContent += `
        <div class="section">
            <h2>✏️ 추천 제목</h2>
            <ol class="title-list">`;
                    titleSuggestions.forEach((title, index) => {
                        htmlContent += `
                <li>${title}</li>`;
                    });
                    htmlContent += `
            </ol>
        </div>`;
                }
                
                if (finalTags.length > 0) {
                    htmlContent += `
        <div class="section">
            <h2>🏷️ 추천 태그</h2>
            <div class="tag-list">`;
                    finalTags.forEach(tag => {
                        htmlContent += `
                <span class="tag-item">#${tag}</span>`;
                    });
                    htmlContent += `
            </div>
        </div>`;
                }
                
                if (recommendations.length > 0) {
                    htmlContent += `
        <div class="section">
            <h2>💡 추천사항</h2>
            <ol class="recommendation-list">`;
                    recommendations.forEach((rec, index) => {
                        htmlContent += `
                <li>${rec}</li>`;
                    });
                    htmlContent += `
            </ol>
        </div>`;
                }
                
                if (improvements.length > 0) {
                    htmlContent += `
        <div class="section">
            <h2>🔧 개선점</h2>`;
                    improvements.forEach((improvement, index) => {
                        htmlContent += `
            <div style="margin-bottom: 20px; padding: 15px; background: white; border-left: 3px solid #ffc107; border-radius: 4px;">
                <h3 style="color: #ffc107; font-size: 1.1em; margin-bottom: 10px;">${index + 1}. ${improvement.title}</h3>
                <p style="line-height: 1.8; color: #555; white-space: pre-line;">${improvement.description}</p>
            </div>`;
                    });
                    htmlContent += `
        </div>`;
                }
                
                if (predictionResult?.category_analysis) {
                    htmlContent += `
        <div class="section">
            <h2>📊 카테고리 분석</h2>
            <p style="line-height: 1.8; color: #555;">${predictionResult.category_analysis}</p>
        </div>`;
                }
                
                htmlContent += `
        <div class="footer">
            <p>본 보고서는 1등 유튜버 되기 서비스를 통해 생성되었습니다.</p>
            <p>© 2024 1등 유튜버 되기. All rights reserved.</p>
        </div>
    </div>
</body>
</html>`;
                
                // 텍스트 형식의 보고서 생성 (PDF용)
                let textContent = `========================================\n`;
                textContent += `유튜브 영상 분석 보고서\n`;
                textContent += `========================================\n\n`;
                textContent += `생성일: ${reportDate}\n\n`;
                
                textContent += `[영상 정보]\n`;
                textContent += `제목: ${videoData.title || 'N/A'}\n`;
                textContent += `카테고리: ${categoryName}\n`;
                textContent += `길이: ${formatLengthDisplay(videoData.length)}\n`;
                textContent += `업로드 예정: ${videoData.upload_time || '미설정'}\n`;
                if (videoData.description) {
                    textContent += `설명: ${videoData.description}\n`;
                }
                textContent += `\n`;
                
                textContent += `[예측 결과]\n`;
                textContent += `예상 조회수: ${predictedViews}회\n`;
                if (predictionResult?.model_used) {
                    textContent += `사용 모델: ${predictionResult.model_used}\n`;
                }
                textContent += `\n`;
                
                if (titleSuggestions.length > 0) {
                    textContent += `[추천 제목]\n`;
                    titleSuggestions.forEach((title, index) => {
                        textContent += `${index + 1}. ${title}\n`;
                    });
                    textContent += `\n`;
                }
                
                if (finalTags.length > 0) {
                    textContent += `[추천 태그]\n`;
                    textContent += `${finalTags.join(', ')}\n\n`;
                }
                
                if (recommendations.length > 0) {
                    textContent += `[추천사항]\n`;
                    recommendations.forEach((rec, index) => {
                        textContent += `${index + 1}. ${rec}\n`;
                    });
                    textContent += `\n`;
                }
                
                if (improvements.length > 0) {
                    textContent += `[개선점]\n`;
                    improvements.forEach((improvement, index) => {
                        textContent += `${index + 1}. ${improvement.title}\n`;
                        textContent += `   ${improvement.description.replace(/\n/g, '\n   ')}\n\n`;
                    });
                }
                
                if (predictionResult?.category_analysis) {
                    textContent += `[카테고리 분석]\n`;
                    textContent += `${predictionResult.category_analysis}\n\n`;
                }
                
                textContent += `========================================\n`;
                textContent += `보고서 끝\n`;
                textContent += `========================================\n`;
                
                // 텍스트 파일로 다운로드
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                
                // 파일명 생성 (제목에서 특수문자 제거)
                const safeTitle = (videoData.title || '영상분석').replace(/[^a-zA-Z0-9가-힣\s]/g, '').trim().substring(0, 30);
                const fileName = `유튜브_분석_보고서_${safeTitle}_${new Date().toISOString().split('T')[0]}.txt`;
                link.download = fileName;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                alert('보고서가 텍스트 파일로 다운로드되었습니다.');
            } catch (error) {
                console.error('보고서 다운로드 오류:', error);
                alert('보고서 다운로드 중 오류가 발생했습니다: ' + error.message);
            }
        }
        
        // 제목 추천 함수 (서버 API 사용)
        async function generateYouTubeTitles(keyword, imageText = '', n = 5) {
            try {
                const response = await fetch(`${API_BASE}/api/titles/generate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        keyword: keyword,
                        imageText: imageText,
                        n: n
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.message || '제목 생성에 실패했습니다.');
                }
                
                // 제목 목록을 줄바꿈으로 연결
                return data.titles.join('\n');
            } catch (error) {
                console.error("Error generating titles:", error);
                throw error;
            }
        }
        
        // 제목 추천을 UI에 표시하는 함수
        async function displayTitleSuggestions(videoData) {
            const loadingDiv = document.getElementById('titleLoading');
            const resultsDiv = document.getElementById('titleResults');
            const titleListDiv = document.getElementById('titleList');

            try {
            loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
                
                const keyword = videoData.title;
                const imageText = videoData.description || '';
                const titlesText = await generateYouTubeTitles(keyword, imageText, 5);
                
                // 제목을 배열로 파싱
                const titles = titlesText.split('\n')
                    .map(title => title.replace(/^\d+[\.\)]\s*/, '').trim())
                    .filter(title => title.length > 0)
                    .slice(0, 5);
                
                // 제목 목록 표시
                titleListDiv.innerHTML = titles.map((title, index) => `
                    <div class="title-suggestion mb-3 p-3 border rounded" style="border-color: rgba(255, 0, 0, 0.3); background-color: rgba(255, 0, 0, 0.05);">
                        <div class="d-flex align-items-center justify-content-between">
                            <div class="flex-grow-1">
                                <span class="badge bg-danger me-2">${index + 1}</span>
                                <span class="title-text text-white">${title}</span>
                            </div>
                            <div class="btn-group" role="group">
                                <button class="btn btn-sm btn-outline-light" onclick="copyTitle('${title.replace(/'/g, "\\'").replace(/"/g, '\\"')}')" title="복사">
                                    <i class="bi bi-clipboard"></i>
                                </button>
                                <button class="btn btn-sm btn-outline-success" onclick="useTitle('${title.replace(/'/g, "\\'").replace(/"/g, '\\"')}')" title="사용">
                                    <i class="bi bi-check"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `).join('');
                
                    loadingDiv.style.display = 'none';
                    resultsDiv.style.display = 'block';
                
                // predictionResult에도 저장
                const predictionResult = JSON.parse(sessionStorage.getItem('predictionResult') || '{}');
                predictionResult.title_suggestions = titles;
                sessionStorage.setItem('predictionResult', JSON.stringify(predictionResult));
                
            } catch (error) {
                console.error("Error displaying title suggestions:", error);
                loadingDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>제목 생성 실패:</strong> ${error.message}
                        <br><small class="mt-2 d-block">인터넷 연결을 확인하고 다시 시도해주세요.</small>
                    </div>
                    <button class="btn btn-outline-danger mt-3" onclick="regenerateTitles()">
                        <i class="bi bi-arrow-clockwise me-2"></i>다시 시도
                    </button>
                `;
            }
        }
        
        // 제목 복사 함수
        function copyTitle(title) {
            navigator.clipboard.writeText(title).then(() => {
                alert('제목이 클립보드에 복사되었습니다!');
            }).catch(err => {
                console.error('복사 실패:', err);
                alert('복사에 실패했습니다.');
            });
        }
        
        // 제목 사용 함수
        function useTitle(title) {
            if (confirm(`"${title}"를 새 제목으로 사용하시겠습니까?`)) {
                const videoData = JSON.parse(sessionStorage.getItem('videoData'));
                videoData.title = title;
                sessionStorage.setItem('videoData', JSON.stringify(videoData));
                
                const titleElement = document.getElementById('currentTitleForTags');
                if (titleElement) {
                    titleElement.textContent = title;
                }
                
                alert('제목이 업데이트되었습니다!');
            }
        }
        
        // 새로운 제목 생성 함수
        function regenerateTitles() {
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
            displayTitleSuggestions(videoData);
        }
        
        // 자동으로 제목 추천 표시
        async function autoGenerateTitles(videoData) {
            if (!videoData) {
                videoData = JSON.parse(sessionStorage.getItem('videoData'));
            }
            
            if (!videoData || !videoData.title) {
                console.log('제목 생성을 위한 영상 정보가 없습니다.');
                return;
            }
            
            await displayTitleSuggestions(videoData);
        }
        
        // 태그 추천 기능
        async function generateTags() {
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
            console.log('태그 추천을 위한 videoData:', videoData);
            
            if (!videoData || !videoData.title) {
                alert('영상 제목이 없습니다. 제목을 입력해주세요.');
                return;
            }
            
            const loadingDiv = document.getElementById('tagLoading');
            const resultsDiv = document.getElementById('tagResults');
            const buttonDiv = document.getElementById('tagGenerateButton');
            
            // 현재 제목과 설명 표시 업데이트
            const titleElement = document.getElementById('currentTitleForTags');
            const descriptionElement = document.getElementById('currentDescriptionForTags');
            if (titleElement) {
                titleElement.textContent = videoData.title;
            }
            if (descriptionElement) {
                const description = videoData.description || "";
                if (description.trim()) {
                    descriptionElement.textContent = description;
                } else {
                    descriptionElement.innerHTML = '<span class="text-muted">설명이 없습니다.</span>';
                }
            }

            // 로딩 상태 표시
                    loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            if (buttonDiv) buttonDiv.style.display = 'none';
            
            try {
                const response = await fetch(`${API_BASE}/api/tags/enrich`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: videoData.title,
                        description: videoData.description || "",
                        top_k: 20,
                        title_sim_threshold: 0.30,
                        tag_abs_threshold: 0.30,
                        extra_k: 20
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: '태그 추천 요청 실패' }));
                    throw new Error(errorData.detail || '태그 추천 요청 실패');
                }

                const data = await response.json();
                
                // 결과 표시
                displayTagResults(data);
                
                    loadingDiv.style.display = 'none';
                    resultsDiv.style.display = 'block';

            } catch (error) {
                console.error("Error generating tags:", error);
                loadingDiv.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>태그 추천 실패:</strong> ${error.message}
                        <br><small class="mt-2 d-block">서버 연결에 문제가 있을 수 있습니다. 잠시 후 다시 시도해주세요.</small>
                    </div>
                    <button class="btn btn-outline-danger mt-3" onclick="generateTags()">
                        <i class="bi bi-arrow-clockwise me-2"></i>다시 시도
                    </button>
                `;
                loadingDiv.style.display = 'block';
                if (buttonDiv) buttonDiv.style.display = 'block';
            }
        }
        
        function displayTagResults(data) {
            // 최종 태그와 추가 태그를 합쳐서 표시
            const finalDiv = document.getElementById('finalTags');
            finalDiv.innerHTML = '';
            
            // 최종 태그와 추가 태그 합치기
            const allRecommendedTags = [
                ...(data.final_tags || []),
                ...(data.extra_tags || [])
            ].slice(0, 20); // 최대 20개로 제한
            
            if (allRecommendedTags.length > 0) {
                allRecommendedTags.forEach(tag => {
                    const badge = createTagBadge(tag, '', 'final');
                    badge.onclick = () => copyToClipboard(badge, tag);
                    badge.style.cursor = 'pointer';
                    badge.title = '클릭하여 복사';
                    finalDiv.appendChild(badge);
                });
            } else {
                finalDiv.innerHTML = '<p class="text-muted mb-0">태그가 없습니다.</p>';
            }
            
            // 후보 태그 표시 (상세 분석에)
            const candidateDiv = document.getElementById('candidateTags');
            if (candidateDiv) {
                candidateDiv.innerHTML = '';
                if (data.candidates && data.candidates.length > 0) {
                    data.candidates.forEach(tag => {
                        const badge = createTagBadge(tag, '');
                        candidateDiv.appendChild(badge);
                    });
                } else {
                    candidateDiv.innerHTML = '<p class="text-muted mb-0">후보 태그가 없습니다.</p>';
                }
            }
            
            // 유사도 점수 표시 (상세 분석에)
            const scoredDiv = document.getElementById('scoredTags');
            if (scoredDiv) {
                scoredDiv.innerHTML = '';
                if (data.scored && data.scored.length > 0) {
                    data.scored.forEach(item => {
                        const badge = createTagBadge(item.tag, item.score.toFixed(3));
                        scoredDiv.appendChild(badge);
                    });
                } else {
                    scoredDiv.innerHTML = '<p class="text-muted mb-0">유사도 점수가 없습니다.</p>';
                }
            }
            
            // 유지된 태그 표시 (상세 분석에)
            const keptDiv = document.getElementById('keptTags');
            if (keptDiv) {
                keptDiv.innerHTML = '';
                if (data.kept && data.kept.length > 0) {
                    data.kept.forEach(tag => {
                        const badge = createTagBadge(tag, '', 'kept');
                        badge.onclick = () => copyToClipboard(badge, tag);
                        badge.style.cursor = 'pointer';
                        badge.title = '클릭하여 복사';
                        keptDiv.appendChild(badge);
                    });
                } else {
                    keptDiv.innerHTML = '<p class="text-muted mb-0">유지된 태그가 없습니다.</p>';
                }
            }
            
            // 제외된 태그 표시 (상세 분석에)
            const droppedDiv = document.getElementById('droppedTags');
            if (droppedDiv) {
                droppedDiv.innerHTML = '';
                if (data.dropped && data.dropped.length > 0) {
                    data.dropped.forEach(tag => {
                        const badge = createTagBadge(tag, '', 'dropped');
                        droppedDiv.appendChild(badge);
                    });
                } else {
                    droppedDiv.innerHTML = '<p class="text-muted mb-0">제외된 태그가 없습니다.</p>';
                }
            }
        }
        
        function createTagBadge(tag, score, className = '') {
            const badge = document.createElement('span');
            badge.className = `tag-badge ${className}`;
            
            // 태그 앞에 # 추가
            let tagText = tag.startsWith('#') ? tag : `#${tag}`;
            
            let innerHTML = tagText;
            if (score) {
                innerHTML += `<span class="tag-score">(${score})</span>`;
            }
            
            badge.innerHTML = innerHTML;
            return badge;
        }
        
        function generateNewTags() {
            document.getElementById('tagResults').style.display = 'none';
            document.getElementById('tagGenerateButton').style.display = 'block';
            generateTags();
        }
        
        // 자동으로 태그 추천 (페이지 로드 시)
        async function autoGenerateTags(videoData) {
            // videoData가 없으면 localStorage에서 다시 가져오기
            if (!videoData) {
                videoData = JSON.parse(sessionStorage.getItem('videoData'));
            }
            
            if (!videoData || !videoData.title) {
                console.log('태그 추천을 위한 영상 정보가 없습니다.');
                return; // 제목이 없으면 자동 실행하지 않음
            }
            
            console.log('태그 추천을 위한 영상 정보:', videoData);
            
            // 현재 제목과 설명 표시
            const titleElement = document.getElementById('currentTitleForTags');
            const descriptionElement = document.getElementById('currentDescriptionForTags');
            if (titleElement) {
                titleElement.textContent = videoData.title;
            }
            if (descriptionElement) {
                const description = videoData.description || "";
                if (description.trim()) {
                    descriptionElement.textContent = description;
                } else {
                    descriptionElement.innerHTML = '<span class="text-muted">설명이 없습니다.</span>';
                }
            }
            
            // 자동으로 태그 추천 실행
            await generateTags();
        }
        
        // 모든 태그 복사 함수
        function copyAllTags() {
            const finalTags = [];
            
            // 최종 태그 수집 (추가 태그 포함)
            const finalDiv = document.getElementById('finalTags');
            if (finalDiv) {
                finalDiv.querySelectorAll('.tag-badge').forEach(badge => {
                    const tagText = badge.textContent.trim();
                    // # 제거하고 순수 태그만 추출
                    const cleanTag = tagText.replace(/^#/, '').replace(/\s*\([^)]*\)$/, '').trim();
                    if (cleanTag && !tagText.includes('(')) {
                        finalTags.push(cleanTag);
                    }
                });
            }
            
            // 모든 태그 합치기
            const allTags = finalTags.join(', ');
            
            if (allTags) {
                navigator.clipboard.writeText(allTags).then(() => {
                    alert('모든 태그가 클립보드에 복사되었습니다!');
            }).catch(err => {
                console.error('클립보드 복사 실패:', err);
                alert('클립보드 복사 실패!');
            });
            } else {
                alert('복사할 태그가 없습니다.');
            }
        }
        
        // 분석 결과 저장 함수 (피드백 결과 전체 저장)
        async function saveAnalysisResult() {
            try {
                console.log('저장 함수 시작');
                
                // 현재 분석 결과 수집
            const videoData = JSON.parse(sessionStorage.getItem('videoData'));
                const predictionResult = JSON.parse(sessionStorage.getItem('predictionResult'));
                
                console.log('videoData:', videoData);
                console.log('predictionResult:', predictionResult);
                
                if (!videoData) {
                    alert('저장할 영상 정보가 없습니다. 다시 입력해주세요.');
                    return;
                }
                
                // 태그 정보 수집
                const finalTags = [];
                const finalDiv = document.getElementById('finalTags');
                if (finalDiv) {
                    finalDiv.querySelectorAll('.tag-badge').forEach(badge => {
                        const tagText = badge.textContent.trim();
                        const cleanTag = tagText.replace(/^#/, '').replace(/\s*\([^)]*\)$/, '').trim();
                        if (cleanTag && !tagText.includes('(')) {
                            finalTags.push(cleanTag);
                        }
                    });
                }
                
                // 피드백 결과 전체 HTML 수집 (메인 컨테이너 사용)
                const mainContainer = document.querySelector('.container');
                console.log('mainContainer:', mainContainer);
                const feedbackContent = mainContainer ? mainContainer.innerHTML : '피드백 내용을 불러올 수 없습니다.';
                
                // 예측 결과가 없으면 기본값으로 설정
                const analysisResult = predictionResult ? {
                    predicted_views: predictionResult.predicted_views,
                    confidence: predictionResult.confidence,
                    recommendations: predictionResult.recommendations,
                    category_analysis: predictionResult.category_analysis,
                    title_suggestions: predictionResult.title_suggestions || [], // 제목 추천 추가
                    tags: finalTags
                } : {
                    predicted_views: 0,
                    confidence: 0,
                    recommendations: ["분석이 완료되지 않았습니다."],
                    category_analysis: "분석 중입니다.",
                    title_suggestions: [], // 제목 추천 추가
                    tags: finalTags
                };
                
                // 저장할 데이터 구성 (피드백 결과 전체)
                const saveData = {
                    id: Date.now(), // 고유 ID
                    video_info: {
                        title: videoData.title,
                        category: videoData.category,
                        length: videoData.length,
                        upload_time: videoData.uploadTime,
                        description: videoData.description,
                        thumbnail_image: videoData.thumbnailImage
                    },
                    analysis_result: analysisResult,
                    feedback_content: feedbackContent, // 피드백 결과 전체 HTML
                    analysis_date: new Date().toISOString(),
                    status: predictionResult ? 'completed' : 'incomplete' // 분석 완료 여부
                };
                
                // 로컬 스토리지에 저장
                const savedAnalyses = JSON.parse(localStorage.getItem('savedAnalyses') || '[]');
                savedAnalyses.push(saveData);
                localStorage.setItem('savedAnalyses', JSON.stringify(savedAnalyses));
                
                console.log('저장 완료:', saveData);
                console.log('전체 저장된 분석:', savedAnalyses);
                
                // 성공 메시지
                showSaveSuccessMessage();
                
            } catch (error) {
                console.error('분석 결과 저장 실패:', error);
                alert('분석 결과 저장에 실패했습니다. 다시 시도해주세요.');
            }
        }
        
        // 저장 성공 메시지 표시
        function showSaveSuccessMessage() {
            // 기존 알림이 있다면 제거
            const existingAlert = document.getElementById('saveSuccessAlert');
            if (existingAlert) {
                existingAlert.remove();
            }
            
            // 성공 메시지 생성
            const alertDiv = document.createElement('div');
            alertDiv.id = 'saveSuccessAlert';
            alertDiv.className = 'alert alert-success alert-dismissible fade show position-fixed';
            alertDiv.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 350px; background-color: rgba(255, 0, 0, 0.8) !important; color: #ffffff !important; border: 1px solid #ff0000 !important;';
            alertDiv.innerHTML = `
                <div class="d-flex align-items-center justify-content-between">
                    <div>
                <i class="bi bi-check-circle me-2"></i>
                <strong>분석 결과가 저장되었습니다!</strong>
                        <div class="mt-2">
                            <a href="mypage.html" class="btn btn-sm btn-outline-light">
                                <i class="bi bi-archive me-1"></i>분석결과 보러가기
                            </a>
                        </div>
                    </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            document.body.appendChild(alertDiv);
            
            // 3초 후 자동 제거
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 3000);
        }
        
        // 저장된 분석 결과 조회 함수
        function getSavedAnalyses() {
            return JSON.parse(localStorage.getItem('savedAnalyses') || '[]');
        }
        
        // 저장된 분석 결과 삭제 함수
        function deleteSavedAnalysis(index) {
            const savedAnalyses = getSavedAnalyses();
            if (index >= 0 && index < savedAnalyses.length) {
                savedAnalyses.splice(index, 1);
                localStorage.setItem('savedAnalyses', JSON.stringify(savedAnalyses));
                return true;
            }
            return false;
        }
    </script>
</body>
</html>
